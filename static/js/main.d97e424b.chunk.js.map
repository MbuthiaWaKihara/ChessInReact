{"version":3,"sources":["components/pieces/King.js","components/pieces/Queen.js","components/pieces/Rook.js","components/pieces/Bishop.js","components/pieces/Knight.js","components/pieces/Pawn.js","components/info/PiecesInfo.js","components/logic/BoardLogic.js","components/logic/PiecesLogic.js","components/logic/KingLogic.js","components/logic/InCheckLogic.js","components/logic/PinLogic.js","components/Chessboard.js","components/Screen.js","components/PromoteOptions.js","components/App.js","index.js"],"names":["React","memo","pieceColor","viewBox","xmlns","version","width","height","style","fill","fillOpacity","fillRule","stroke","strokeWidth","strokeLinecap","strokeLinejoin","strokeMiterlimit","strokeDasharray","strokeOpacity","d","id","opacity","transform","cx","cy","r","initialPieceInfo","pieceId","pieceName","hasBeenCaptured","noOfMoves","positionOnBoard","rankNumber","fileNumber","determineChessboardSituation","chessboardInfo","currentPieceInfo","chessboardSituation","associatedFilesSituationHolder","forEach","rankInfo","rankIndex","associatedFiles","fileInfo","fileIndex","piece","pieceIndex","hasPiece","pieceMoves","associatedFilesSituation","generatePossibleMoves","isLayoutDefault","history","possibleMoves","pieceRank","pieceFile","moves","length","currentRank","currentFile","kingTracker","kingInfo","kingPossibleMoves","isKingInCheck","status","attackers","move","moveId","substring","search","isUnderPressure","moveIndex","canMyPieceHelp","attackerInfo","numberOfAttackers","possibleSquares","potentialRank","parseInt","potentialFile","kingRank","kingFile","canIntercept","rankCounter","fileCounter","isMyPiecePinned","targetRank","targetFile","turn","pieceIsPinned","copySituation","JSON","parse","stringify","canMyPieceBeHere","chessboardLayout","pieceCanBeHere","copyPieceInfo","associatedFilesHolder","fileNumbers","fileName","filesPlacement","ranksPlacement","transformPiece","pieceSituation","action","type","value","switchTurn","changePromotionState","promotionPiece","setPromotionPiece","setScreenContent","useState","checkmate","setCheckmate","initialPiecesInfo","useReducer","changePieceInfo","from","to","isPiecePinned","activityPhase","setActivityPhase","currentScheme","isColorSchemeDefault","targetSquare","targetCheckSquare","colorScheme","setColorScheme","color","initialColor","squareClass","square","squareIndex","createChessboardInfo","currentHistory","copy","push","newmove","updateHistory","default","intermediateKingPossibleMoves","newKingPossibleMoves","firstKingMoves","secondKingMoves","initialFirst","initialOther","includes","refineKingMoves","king","kingIndex","kingColor","kingCanBeHere","canMyKingBeHere","useEffect","message","verdict","kingInDanger","kingCanBeSaved","kingId","launchPlayerActivity","pieceInfo","myPossibleMoves","myPieceIsPinned","newPossibleSquares","targetPiece","myPiece","currentPieces","isSquareWithinPossible","isCaseEnPassant","enPassantId","isCaseCastlesShort","isCaseCastlesLong","castleId","moveInfo","split","kingInCheck","allowedMove","displayBoard","map","singlePiece","onClick","className","key","backgroundColor","display","flexFlow","alignItems","alignContent","border","rank","file","index","Fragment","screenContent","borderTop","borderLeft","borderRight","fontSize","fontWeight","displayStatus","selectPromotionPiece","changeTurn","currentTurn","initialChessboardLayout","exchangeChessBoardLayout","currentLayout","newDefault","reverse","App","switchChessBoardLayout","dispatchTurn","promotion","setPromotion","moveCount","setMoveCount","previousCount","rootNode","document","querySelector","ReactDOM","render"],"mappings":"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","file":"static/js/main.d97e424b.chunk.js","sourcesContent":["import React from 'react';\r\n\r\n//returns a king svg\r\n\r\nconst King = ({pieceColor}) => \r\n{\r\n    return(\r\n        <>\r\n           {\r\n               pieceColor === \"white\" &&\r\n               <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width={150} height={150}>\r\n            <g\r\n                style={{\r\n                fill: \"none\",\r\n                fillOpacity: 1,\r\n                fillRule: \"evenodd\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinecap: \"round\",\r\n                strokeLinejoin: \"round\",\r\n                strokeMiterlimit: 4,\r\n                strokeDasharray: \"none\",\r\n                strokeOpacity: 1,\r\n                }}\r\n            >\r\n                <path\r\n                d=\"M 22.5,11.63 L 22.5,6\"\r\n                style={{ fill: \"none\", stroke: \"#000000\", strokeLinejoin: \"miter\" }}\r\n                />\r\n                <path\r\n                d=\"M 20,8 L 25,8\"\r\n                style={{ fill: \"none\", stroke: \"#000000\", strokeLinejoin: \"miter\" }}\r\n                />\r\n                <path\r\n                d=\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\"\r\n                style={{\r\n                    fill: \"#ffffff\",\r\n                    stroke: \"#000000\",\r\n                    strokeLinecap: \"butt\",\r\n                    strokeLinejoin: \"miter\"\r\n                }}\r\n                />\r\n                <path\r\n                d=\"M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z \"\r\n                style={{ fill: \"#ffffff\", stroke: \"#000000\" }}\r\n                />\r\n                <path\r\n                d=\"M 11.5,30 C 17,27 27,27 32.5,30\"\r\n                style={{ fill: \"none\", stroke: \"#000000\" }}\r\n                />\r\n                <path\r\n                d=\"M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5\"\r\n                style={{ fill: \"none\", stroke: \"#000000\" }}\r\n                />\r\n                <path\r\n                d=\"M 11.5,37 C 17,34 27,34 32.5,37\"\r\n                style={{ fill: \"none\", stroke: \"#000000\" }}\r\n                />\r\n            </g>\r\n            </svg>\r\n           }\r\n           {\r\n               pieceColor === \"black\" &&\r\n               <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width={150} height={150}>\r\n                <g\r\n                    style={{\r\n                    fill: \"none\",\r\n                    fillOpacity: 1,\r\n                    fillRule: \"evenodd\",\r\n                    stroke: \"#000000\",\r\n                    strokeWidth: \"1.5\",\r\n                    strokeLinecap: \"round\",\r\n                    strokeLinejoin: \"round\",\r\n                    strokeMiterlimit: 4,\r\n                    strokeDasharray: \"none\",\r\n                    strokeOpacity: 1\r\n                    }}\r\n                >\r\n                    <path\r\n                    d=\"M 22.5,11.63 L 22.5,6\"\r\n                    style={{ fill: \"none\", stroke: \"#000000\", strokeLinejoin: \"miter\" }}\r\n                    id=\"path6570\"\r\n                    />\r\n                    <path\r\n                    d=\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\"\r\n                    style={{\r\n                        fill: \"#000000\",\r\n                        fillOpacity: 1,\r\n                        strokeLinecap: \"butt\",\r\n                        strokeLinejoin: \"miter\"\r\n                    }}\r\n                    />\r\n                    <path\r\n                    d=\"M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z \"\r\n                    style={{ fill: \"#000000\", stroke: \"#000000\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 20,8 L 25,8\"\r\n                    style={{ fill: \"none\", stroke: \"#000000\", strokeLinejoin: \"miter\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.51,26.6 L 22.5,24.5 C 20,18 9.906,14 6.997,19.85 C 4.5,25.5 11.85,28.85 11.85,28.85\"\r\n                    style={{ fill: \"none\", stroke: \"#ffffff\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 11.5,30 C 17,27 27,27 32.5,30 M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5 M 11.5,37 C 17,34 27,34 32.5,37\"\r\n                    style={{ fill: \"none\", stroke: \"#ffffff\" }}\r\n                    />\r\n                </g>\r\n                </svg>\r\n           }\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(King);\r\n\r\n","import React from 'react';\r\n\r\n//returns a queen svg\r\n\r\nconst Queen = ({pieceColor}) => \r\n{\r\n    return(\r\n        <>\r\n           {\r\n               pieceColor === \"white\" &&\r\n               <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width={150} height={150}>\r\n                <g\r\n                    style={{\r\n                    opacity: 1,\r\n                    fill: \"#ffffff\",\r\n                    fillOpacity: 1,\r\n                    fillRule: \"evenodd\",\r\n                    stroke: \"#000000\",\r\n                    strokeWidth: \"1.5\",\r\n                    strokeLinecap: \"round\",\r\n                    strokeLinejoin: \"round\",\r\n                    strokeMiterlimit: 4,\r\n                    strokeDasharray: \"none\",\r\n                    strokeOpacity: 1\r\n                    }}\r\n                >\r\n                    <path\r\n                    d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"\r\n                    transform=\"translate(-1,-1)\"\r\n                    />\r\n                    <path\r\n                    d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"\r\n                    transform=\"translate(15.5,-5.5)\"\r\n                    />\r\n                    <path\r\n                    d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"\r\n                    transform=\"translate(32,-1)\"\r\n                    />\r\n                    <path\r\n                    d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"\r\n                    transform=\"translate(7,-4.5)\"\r\n                    />\r\n                    <path\r\n                    d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"\r\n                    transform=\"translate(24,-4)\"\r\n                    />\r\n                    <path\r\n                    d=\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38,14 L 31,25 L 31,11 L 25.5,24.5 L 22.5,9.5 L 19.5,24.5 L 14,10.5 L 14,25 L 7,14 L 9,26 z \"\r\n                    style={{ strokeLinecap: \"butt\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z \"\r\n                    style={{ strokeLinecap: \"butt\" }}\r\n                    />\r\n                    <path d=\"M 11.5,30 C 15,29 30,29 33.5,30\" style={{ fill: \"none\" }} />\r\n                    <path d=\"M 12,33.5 C 18,32.5 27,32.5 33,33.5\" style={{ fill: \"none\" }} />\r\n                </g>\r\n                </svg>\r\n           }\r\n           {\r\n               pieceColor === \"black\" &&\r\n               <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width={150} height={150}>\r\n                <g\r\n                    style={{\r\n                    opacity: 1,\r\n                    fill: '000000',\r\n                    fillOpacity: 1,\r\n                    fillRule: \"evenodd\",\r\n                    stroke: \"#000000\",\r\n                    strokeWidth: \"1.5\",\r\n                    strokeLinecap: \"round\",\r\n                    strokeLinejoin: \"round\",\r\n                    strokeMiterlimit: 4,\r\n                    strokeDasharray: \"none\",\r\n                    strokeOpacity: 1\r\n                    }}\r\n                >\r\n                    <g style={{ fill: \"#000000\", stroke: \"none\" }}>\r\n                    <circle cx={6} cy={12} r=\"2.75\" />\r\n                    <circle cx={14} cy={9} r=\"2.75\" />\r\n                    <circle cx=\"22.5\" cy={8} r=\"2.75\" />\r\n                    <circle cx={31} cy={9} r=\"2.75\" />\r\n                    <circle cx={39} cy={12} r=\"2.75\" />\r\n                    </g>\r\n                    <path\r\n                    d=\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\"\r\n                    style={{ strokeLinecap: \"butt\", stroke: \"#000000\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z\"\r\n                    style={{ strokeLinecap: \"butt\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 11,38.5 A 35,35 1 0 0 34,38.5\"\r\n                    style={{ fill: \"none\", stroke: \"#000000\", strokeLinecap: \"butt\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 11,29 A 35,35 1 0 1 34,29\"\r\n                    style={{ fill: \"none\", stroke: \"#ffffff\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 12.5,31.5 L 32.5,31.5\"\r\n                    style={{ fill: \"none\", stroke: \"#ffffff\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 11.5,34.5 A 35,35 1 0 0 33.5,34.5\"\r\n                    style={{ fill: \"none\", stroke: \"#ffffff\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 10.5,37.5 A 35,35 1 0 0 34.5,37.5\"\r\n                    style={{ fill: \"none\", stroke: \"#ffffff\" }}\r\n                    />\r\n                </g>\r\n                </svg>\r\n           }\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(Queen);","import React from 'react';\r\n\r\n//returns a rook svg\r\n\r\nconst Rook = ({pieceColor}) => \r\n{\r\n    return(\r\n        <>\r\n           {\r\n               pieceColor === \"white\" &&\r\n               <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width={150} height={150}>\r\n                <g\r\n                    style={{\r\n                    opacity: 1,\r\n                    fill: \"#ffffff\",\r\n                    fillOpacity: 1,\r\n                    fillRule: \"evenodd\",\r\n                    stroke: \"#000000\",\r\n                    strokeWidth: \"1.5\",\r\n                    strokeLinecap: \"round\",\r\n                    strokeLinejoin: \"round\",\r\n                    strokeMiterlimit: 4,\r\n                    strokeDasharray: \"none\",\r\n                    strokeOpacity: 1\r\n                    }}\r\n                >\r\n                    <path\r\n                    d=\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \"\r\n                    style={{ strokeLinecap: \"butt\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \"\r\n                    style={{ strokeLinecap: \"butt\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14\"\r\n                    style={{ strokeLinecap: \"butt\" }}\r\n                    />\r\n                    <path d=\"M 34,14 L 31,17 L 14,17 L 11,14\" />\r\n                    <path\r\n                    d=\"M 31,17 L 31,29.5 L 14,29.5 L 14,17\"\r\n                    style={{ strokeLinecap: \"butt\", strokeLinejoin: \"miter\" }}\r\n                    />\r\n                    <path d=\"M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5\" />\r\n                    <path\r\n                    d=\"M 11,14 L 34,14\"\r\n                    style={{ fill: \"none\", stroke: \"#000000\", strokeLinejoin: \"miter\" }}\r\n                    />\r\n                </g>\r\n                </svg>\r\n\r\n           }\r\n           {\r\n               pieceColor === \"black\" &&\r\n               <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width={150} height={150}>\r\n                <g\r\n                    style={{\r\n                    opacity: 1,\r\n                    fill: '000000',\r\n                    fillOpacity: 1,\r\n                    fillRule: \"evenodd\",\r\n                    stroke: \"#000000\",\r\n                    strokeWidth: \"1.5\",\r\n                    strokeLinecap: \"round\",\r\n                    strokeLinejoin: \"round\",\r\n                    strokeMiterlimit: 4,\r\n                    strokeDasharray: \"none\",\r\n                    strokeOpacity: 1\r\n                    }}\r\n                >\r\n                    <path\r\n                    d=\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \"\r\n                    style={{ strokeLinecap: \"butt\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z \"\r\n                    style={{ strokeLinecap: \"butt\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \"\r\n                    style={{ strokeLinecap: \"butt\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z \"\r\n                    style={{ strokeLinecap: \"butt\", strokeLinejoin: \"miter\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z \"\r\n                    style={{ strokeLinecap: \"butt\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z \"\r\n                    style={{ strokeLinecap: \"butt\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 12,35.5 L 33,35.5 L 33,35.5\"\r\n                    style={{\r\n                        fill: \"none\",\r\n                        stroke: \"#ffffff\",\r\n                        strokeWidth: 1,\r\n                        strokeLinejoin: \"miter\"\r\n                    }}\r\n                    />\r\n                    <path\r\n                    d=\"M 13,31.5 L 32,31.5\"\r\n                    style={{\r\n                        fill: \"none\",\r\n                        stroke: \"#ffffff\",\r\n                        strokeWidth: 1,\r\n                        strokeLinejoin: \"miter\"\r\n                    }}\r\n                    />\r\n                    <path\r\n                    d=\"M 14,29.5 L 31,29.5\"\r\n                    style={{\r\n                        fill: \"none\",\r\n                        stroke: \"#ffffff\",\r\n                        strokeWidth: 1,\r\n                        strokeLinejoin: \"miter\"\r\n                    }}\r\n                    />\r\n                    <path\r\n                    d=\"M 14,16.5 L 31,16.5\"\r\n                    style={{\r\n                        fill: \"none\",\r\n                        stroke: \"#ffffff\",\r\n                        strokeWidth: 1,\r\n                        strokeLinejoin: \"miter\"\r\n                    }}\r\n                    />\r\n                    <path\r\n                    d=\"M 11,14 L 34,14\"\r\n                    style={{\r\n                        fill: \"none\",\r\n                        stroke: \"#ffffff\",\r\n                        strokeWidth: 1,\r\n                        strokeLinejoin: \"miter\"\r\n                    }}\r\n                    />\r\n                </g>\r\n                </svg>\r\n           }\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(Rook);","import React from 'react';\r\n\r\n//returns a bishop svg\r\n\r\nconst Bishop = ({pieceColor}) => \r\n{\r\n    return(\r\n        <>\r\n           {\r\n               pieceColor === \"white\" &&\r\n               <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width={150} height={150}>\r\n                <g\r\n                    style={{\r\n                    opacity: 1,\r\n                    fill: \"none\",\r\n                    fillRule: \"evenodd\",\r\n                    fillOpacity: 1,\r\n                    stroke: \"#000000\",\r\n                    strokeWidth: \"1.5\",\r\n                    strokeLinecap: \"round\",\r\n                    strokeLinejoin: \"round\",\r\n                    strokeMiterlimit: 4,\r\n                    strokeDasharray: \"none\",\r\n                    strokeOpacity: 1\r\n                    }}\r\n                >\r\n                    <g style={{ fill: \"#ffffff\", stroke: \"#000000\", strokeLinecap: \"butt\" }}>\r\n                    <path d=\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z\" />\r\n                    <path d=\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" />\r\n                    <path d=\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" />\r\n                    </g>\r\n                    <path\r\n                    d=\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\"\r\n                    style={{ fill: \"none\", stroke: \"#000000\", strokeLinejoin: \"miter\" }}\r\n                    />\r\n                </g>\r\n                </svg>\r\n\r\n           }\r\n           {\r\n               pieceColor === \"black\" &&\r\n               <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width={150} height={150}>\r\n                <g\r\n                    style={{\r\n                    opacity: 1,\r\n                    fill: \"none\",\r\n                    fillRule: \"evenodd\",\r\n                    fillOpacity: 1,\r\n                    stroke: \"#000000\",\r\n                    strokeWidth: \"1.5\",\r\n                    strokeLinecap: \"round\",\r\n                    strokeLinejoin: \"round\",\r\n                    strokeMiterlimit: 4,\r\n                    strokeDasharray: \"none\",\r\n                    strokeOpacity: 1\r\n                    }}\r\n                >\r\n                    <g style={{ fill: \"#000000\", stroke: \"#000000\", strokeLinecap: \"butt\" }}>\r\n                    <path d=\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z\" />\r\n                    <path d=\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" />\r\n                    <path d=\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" />\r\n                    </g>\r\n                    <path\r\n                    d=\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\"\r\n                    style={{ fill: \"none\", stroke: \"#ffffff\", strokeLinejoin: \"miter\" }}\r\n                    />\r\n                </g>\r\n                </svg>\r\n           }\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(Bishop);","import React from 'react';\r\n\r\n//returns a knight svg\r\n\r\nconst Knight = ({pieceColor}) => \r\n{\r\n    return(\r\n        <>\r\n           {\r\n               pieceColor === \"white\" &&\r\n               <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width={150} height={150}>\r\n               <g\r\n                 style={{\r\n                   opacity: 1,\r\n                   fill: \"none\",\r\n                   fillOpacity: 1,\r\n                   fillRule: \"evenodd\",\r\n                   stroke: \"#000000\",\r\n                   strokeWidth: \"1.5\",\r\n                   strokeLinecap: \"round\",\r\n                   strokeLinejoin: \"round\",\r\n                   strokeMiterlimit: 4,\r\n                   strokeDasharray: \"none\",\r\n                   strokeOpacity: 1\r\n                 }}\r\n               >\r\n                 <path\r\n                   d=\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\"\r\n                   style={{ fill: \"#ffffff\", stroke: \"#000000\" }}\r\n                 />\r\n                 <path\r\n                   d=\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\"\r\n                   style={{ fill: \"#ffffff\", stroke: \"#000000\" }}\r\n                 />\r\n                 <path\r\n                   d=\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\"\r\n                   style={{ fill: \"#000000\", stroke: \"#000000\" }}\r\n                 />\r\n                 <path\r\n                   d=\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\"\r\n                   transform=\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\"\r\n                   style={{ fill: \"#000000\", stroke: \"#000000\" }}\r\n                 />\r\n               </g>\r\n             </svg>\r\n\r\n           }\r\n           {\r\n               pieceColor === \"black\" &&\r\n               <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width={150} height={150}>\r\n                <g\r\n                    style={{\r\n                    opacity: 1,\r\n                    fill: \"none\",\r\n                    fillOpacity: 1,\r\n                    fillRule: \"evenodd\",\r\n                    stroke: \"#000000\",\r\n                    strokeWidth: \"1.5\",\r\n                    strokeLinecap: \"round\",\r\n                    strokeLinejoin: \"round\",\r\n                    strokeMiterlimit: 4,\r\n                    strokeDasharray: \"none\",\r\n                    strokeOpacity: 1\r\n                    }}\r\n                >\r\n                    <path\r\n                    d=\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\"\r\n                    style={{ fill: \"#000000\", stroke: \"#000000\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\"\r\n                    style={{ fill: \"#000000\", stroke: \"#000000\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\"\r\n                    style={{ fill: \"#ffffff\", stroke: \"#ffffff\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\"\r\n                    transform=\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\"\r\n                    style={{ fill: \"#ffffff\", stroke: \"#ffffff\" }}\r\n                    />\r\n                    <path\r\n                    d=\"M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z \"\r\n                    style={{ fill: \"#ffffff\", stroke: \"none\" }}\r\n                    />\r\n                </g>\r\n                </svg>\r\n           }\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(Knight);","import React from 'react';\r\n\r\n//returns a pawn svg\r\n\r\nconst Pawn = ({pieceColor}) => \r\n{\r\n    return(\r\n        <>\r\n           {\r\n               pieceColor === \"white\" &&\r\n               <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width={150} height={150}>\r\n                <path\r\n                    d=\"M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z \"\r\n                    style={{\r\n                    opacity: 1,\r\n                    fill: \"#ffffff\",\r\n                    fillOpacity: 1,\r\n                    fillRule: \"nonzero\",\r\n                    stroke: \"#000000\",\r\n                    strokeWidth: \"1.5\",\r\n                    strokeLinecap: \"round\",\r\n                    strokeLinejoin: \"miter\",\r\n                    strokeMiterlimit: 4,\r\n                    strokeDasharray: \"none\",\r\n                    strokeOpacity: 1\r\n                    }}\r\n                />\r\n                </svg>\r\n\r\n           }\r\n           {\r\n               pieceColor === \"black\" &&\r\n               <svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width={150} height={150}>\r\n                <path\r\n                    d=\"M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z \"\r\n                    style={{\r\n                    opacity: 1,\r\n                    fill: \"#000000\",\r\n                    fillOpacity: 1,\r\n                    fillRule: \"nonzero\",\r\n                    stroke: \"#000000\",\r\n                    strokeWidth: \"1.5\",\r\n                    strokeLinecap: \"round\",\r\n                    strokeLinejoin: \"miter\",\r\n                    strokeMiterlimit: 4,\r\n                    strokeDasharray: \"none\",\r\n                    strokeOpacity: 1\r\n                    }}\r\n                />\r\n                </svg>\r\n           }\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(Pawn);","//this constant introduces the app to the various chess pieces\r\n//it also tells the app how to place them at first\r\nexport const initialPieceInfo = [\r\n    {\r\n        pieceId: 1,\r\n        pieceName: 'Rook',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 1,\r\n            fileNumber: 1,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 2,\r\n        pieceName: 'Rook',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 1,\r\n            fileNumber: 8,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 3,\r\n        pieceName: 'Rook',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 8,\r\n            fileNumber: 1,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 4,\r\n        pieceName: 'Rook',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 8,\r\n            fileNumber: 8,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 5,\r\n        pieceName: 'Knight',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 1,\r\n            fileNumber: 2,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 6,\r\n        pieceName: 'Knight',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 1,\r\n            fileNumber: 7,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 7,\r\n        pieceName: 'Knight',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 8,\r\n            fileNumber: 2,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 8,\r\n        pieceName: 'Knight',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 8,\r\n            fileNumber: 7,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 9,\r\n        pieceName: 'Bishop',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 1,\r\n            fileNumber: 3,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 10,\r\n        pieceName: 'Bishop',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 1,\r\n            fileNumber: 6,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 11,\r\n        pieceName: 'Bishop',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 8,\r\n            fileNumber: 3,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 12,\r\n        pieceName: 'Bishop',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 8,\r\n            fileNumber: 6,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 13,\r\n        pieceName: 'Queen',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 1,\r\n            fileNumber: 4,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 14,\r\n        pieceName: 'Queen',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 8,\r\n            fileNumber: 4,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 15,\r\n        pieceName: 'King',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 1,\r\n            fileNumber: 5,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 16,\r\n        pieceName: 'King',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 8,\r\n            fileNumber: 5,\r\n        }\r\n    },\r\n    {\r\n        pieceId: 17,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 2,\r\n            fileNumber: 1,\r\n        }\r\n    },{\r\n        pieceId: 18,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 2,\r\n            fileNumber: 2,\r\n        }\r\n    },{\r\n        pieceId: 19,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 2,\r\n            fileNumber: 3,\r\n        }\r\n    },{\r\n        pieceId: 20,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 2,\r\n            fileNumber: 4,\r\n        }\r\n    },{\r\n        pieceId: 21,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 2,\r\n            fileNumber: 5,\r\n        }\r\n    },{\r\n        pieceId: 22,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 2,\r\n            fileNumber: 6,\r\n        }\r\n    },{\r\n        pieceId: 23,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 2,\r\n            fileNumber: 7,\r\n        }\r\n    },{\r\n        pieceId: 24,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'white',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 2,\r\n            fileNumber: 8,\r\n        }\r\n    },{\r\n        pieceId: 25,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 7,\r\n            fileNumber: 1,\r\n        }\r\n    },{\r\n        pieceId: 26,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 7,\r\n            fileNumber: 2,\r\n        }\r\n    },{\r\n        pieceId: 27,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 7,\r\n            fileNumber: 3,\r\n        }\r\n    },{\r\n        pieceId: 28,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 7,\r\n            fileNumber: 4,\r\n        }\r\n    },{\r\n        pieceId: 29,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 7,\r\n            fileNumber: 5,\r\n        }\r\n    },{\r\n        pieceId: 30,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 7,\r\n            fileNumber: 6,\r\n        }\r\n    },{\r\n        pieceId: 31,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 7,\r\n            fileNumber: 7,\r\n        }\r\n    },{\r\n        pieceId: 32,\r\n        pieceName: 'Pawn',\r\n        pieceColor: 'black',\r\n        hasBeenCaptured: false,\r\n        noOfMoves: 0,\r\n        positionOnBoard: {\r\n            rankNumber: 7,\r\n            fileNumber: 8,\r\n        }\r\n    },\r\n];\r\n\r\n","//method that creates a chessboard based on the layout given\r\nexport const createChessboardInfo = (chessboardLayout, colorScheme) => {\r\n\r\n    //a variable that will store the chessboard when the app is first loaded\r\n    //or when a user changes the layout or color scheme\r\n    let chessboardInfo = [];\r\n    let associatedFilesHolder = [];\r\n    let color;\r\n    let initialColor;\r\n    let squareClass;\r\n\r\n    //first form a chessboard array (an array of 8 members with each member having an array property with 8 members 8X8)\r\n    for(let currentRank = 0; currentRank < 8; currentRank++){\r\n\r\n        //prepare an array that holds info about the files associated with current rank\r\n        for(let fileCounter = 0; fileCounter < 8; fileCounter++){\r\n       \r\n            associatedFilesHolder = [\r\n                ...associatedFilesHolder,\r\n                {\r\n                    fileNumber: chessboardLayout.fileNumbers[fileCounter],\r\n                    fileName: chessboardLayout.filesPlacement[fileCounter],\r\n                }\r\n            ];\r\n        }\r\n\r\n        chessboardInfo = [\r\n            ...chessboardInfo,\r\n            {\r\n                rankNumber: chessboardLayout.ranksPlacement[currentRank],\r\n                associatedFiles: [\r\n                    ...associatedFilesHolder\r\n                ]\r\n            }\r\n        ];\r\n\r\n        associatedFilesHolder = [];\r\n    }\r\n\r\n    //then conditionally color the chessboard according to the incoming color scheme\r\n    let chessboardCopy = chessboardInfo;\r\n    chessboardCopy.forEach(\r\n        (rankInfo, rankIndex) => {\r\n            \r\n            if(rankIndex % 2 === 0){\r\n                initialColor = '#ccfbfc';\r\n            }else{\r\n                initialColor = '#4edbde';\r\n            }\r\n    \r\n            rankInfo.associatedFiles.forEach(\r\n                (fileInfo, fileIndex) => {\r\n\r\n                    if(colorScheme.isColorSchemeDefault){\r\n                        squareClass = 'normal';\r\n                       if(fileIndex === 0){\r\n                           color = initialColor;\r\n                       }else{\r\n                          if(fileIndex % 2 === 1){\r\n                            if(initialColor === '#4edbde') color = '#ccfbfc';\r\n                            if(initialColor === '#ccfbfc') color = '#4edbde';\r\n                          }else{\r\n                            color = initialColor;\r\n                          }\r\n                        }\r\n\r\n                        chessboardInfo[rankIndex].associatedFiles[fileIndex] = {\r\n                            ...fileInfo,\r\n                            color,\r\n                            squareClass,\r\n                        }\r\n                    }else{\r\n                        if(colorScheme.type === 'POSSIBLE_MOVES'){\r\n\r\n                            if(`${chessboardInfo[rankIndex].rankNumber}.${chessboardInfo[rankIndex].associatedFiles[fileIndex].fileNumber}` === colorScheme.targetSquare){\r\n                                squareClass = 'selectedInMove';\r\n                                chessboardInfo[rankIndex].associatedFiles[fileIndex] = {\r\n                                    ...fileInfo,\r\n                                    squareClass,\r\n                                }\r\n                            }else  if(`${chessboardInfo[rankIndex].rankNumber}.${chessboardInfo[rankIndex].associatedFiles[fileIndex].fileNumber}` === colorScheme.targetCheckSquare){\r\n                                squareClass = 'check';\r\n                                chessboardInfo[rankIndex].associatedFiles[fileIndex] = {\r\n                                    ...fileInfo,\r\n                                    squareClass,\r\n                                }\r\n                            }else{\r\n                               squareClass = 'normal';\r\n                                if(fileIndex === 0){\r\n                                    color = initialColor;\r\n                                }else{\r\n                                    if(fileIndex % 2 === 1){\r\n                                        if(initialColor === '#4edbde') color = '#ccfbfc';\r\n                                        if(initialColor === '#ccfbfc') color = '#4edbde';\r\n                                    }else{\r\n                                        color = initialColor;\r\n                                    }\r\n                                    }\r\n\r\n                                    chessboardInfo[rankIndex].associatedFiles[fileIndex] = {\r\n                                        ...fileInfo,\r\n                                        color,\r\n                                        squareClass,\r\n                                    }\r\n                            }\r\n  \r\n\r\n                            colorScheme.possibleSquares.forEach(\r\n                                (square, squareIndex) => {\r\n                                    if(fileIndex === 0){\r\n                                        color = initialColor;\r\n                                    }else{\r\n                                        if(fileIndex % 2 === 1){\r\n                                            if(initialColor === '#4edbde') color = '#ccfbfc';\r\n                                            if(initialColor === '#ccfbfc') color = '#4edbde';\r\n                                        }else{\r\n                                            color = initialColor;\r\n                                        }\r\n                                        }\r\n\r\n                                    if(`${chessboardInfo[rankIndex].rankNumber}.${chessboardInfo[rankIndex].associatedFiles[fileIndex].fileNumber}` === square.substring(0,3)){\r\n                                        squareClass = 'amongPossibleSquares';\r\n                                        chessboardInfo[rankIndex].associatedFiles[fileIndex] = {\r\n                                            ...fileInfo,\r\n                                            color,\r\n                                            squareClass,\r\n                                        }\r\n                                    }\r\n\r\n                                    let capture = square.search(\"X\")\r\n                                    if(capture !== -1){\r\n                                        if(`${chessboardInfo[rankIndex].rankNumber}.${chessboardInfo[rankIndex].associatedFiles[fileIndex].fileNumber}` === square.substring(0,3)){\r\n                                            squareClass = 'amongPossibleCaptures';\r\n                                            chessboardInfo[rankIndex].associatedFiles[fileIndex] = {\r\n                                                ...fileInfo,\r\n                                                squareClass,\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            );\r\n                        }\r\n\r\n                       if(colorScheme.type === 'SHOW_CHECK'){\r\n                            if(`${chessboardInfo[rankIndex].rankNumber}.${chessboardInfo[rankIndex].associatedFiles[fileIndex].fileNumber}` === colorScheme.targetCheckSquare){\r\n                                squareClass = 'check';\r\n                                chessboardInfo[rankIndex].associatedFiles[fileIndex] = {\r\n                                    ...fileInfo,\r\n                                    squareClass,\r\n                                }\r\n                            }else{\r\n                                squareClass = 'normal';\r\n                                 if(fileIndex === 0){\r\n                                     color = initialColor;\r\n                                 }else{\r\n                                     if(fileIndex % 2 === 1){\r\n                                         if(initialColor === '#4edbde') color = '#ccfbfc';\r\n                                         if(initialColor === '#ccfbfc') color = '#4edbde';\r\n                                     }else{\r\n                                         color = initialColor;\r\n                                     }\r\n                                     }\r\n \r\n                                     chessboardInfo[rankIndex].associatedFiles[fileIndex] = {\r\n                                         ...fileInfo,\r\n                                         color,\r\n                                         squareClass,\r\n                                     }\r\n                             }\r\n                       }\r\n\r\n                        //not isColorSchemeDefault is here\r\n                    }\r\n                }\r\n            );\r\n\r\n            \r\n        }\r\n    );\r\n\r\n    return chessboardInfo;\r\n}\r\n\r\n\r\n//a method that determines which pieces are where on the chessboard, called as chessboardSituation\r\n//this method produces an array that can be used to generate possible moves\r\nexport const determineChessboardSituation = (chessboardInfo, currentPieceInfo) => {\r\n    let chessboardSituation = [];\r\n    let associatedFilesSituationHolder = [];\r\n\r\n    chessboardInfo.forEach(\r\n        (rankInfo, rankIndex) => {\r\n            rankInfo.associatedFiles.forEach(\r\n                (fileInfo, fileIndex) => {\r\n                    currentPieceInfo.forEach(\r\n                        (piece, pieceIndex) => {\r\n                            if(!piece.hasBeenCaptured && piece.positionOnBoard.rankNumber === rankInfo.rankNumber && piece.positionOnBoard.fileNumber === fileInfo.fileNumber){\r\n                                associatedFilesSituationHolder = [\r\n                                    ...associatedFilesSituationHolder,\r\n                                    {\r\n                                        fileNumber: fileInfo.fileNumber,\r\n                                        hasPiece: true,\r\n                                        pieceId: piece.pieceId,\r\n                                        pieceName: piece.pieceName,\r\n                                        pieceColor: piece.pieceColor,\r\n                                        pieceMoves:piece.noOfMoves,\r\n                                        positionOnBoard: {\r\n                                            ...piece.positionOnBoard\r\n                                        }\r\n                                    }\r\n                                ];\r\n                            }\r\n                        }\r\n                    );\r\n\r\n                    if(!associatedFilesSituationHolder[fileIndex]){\r\n                        associatedFilesSituationHolder = [\r\n                            ...associatedFilesSituationHolder,\r\n                            {\r\n                                fileNumber: fileInfo.fileNumber,\r\n                                hasPiece: false,\r\n                            }\r\n                        ];\r\n                    }\r\n                }\r\n            );\r\n\r\n            chessboardSituation = [\r\n                ...chessboardSituation,\r\n                {\r\n                    rankNumber: rankInfo.rankNumber,\r\n                    associatedFilesSituation: associatedFilesSituationHolder,\r\n                }\r\n            ]\r\n\r\n            associatedFilesSituationHolder = [];\r\n        }\r\n    );\r\n\r\n    return chessboardSituation;\r\n}","\r\n//this method will generate an array of possible moves for every piece currently on the board\r\n//the method relies on the current board situation\r\nexport const generatePossibleMoves = (chessboardSituation, isLayoutDefault, history) => {\r\n    let possibleMoves = [];\r\n\r\n    chessboardSituation.forEach(\r\n        (rankInfo, rankIndex) => {\r\n            rankInfo.associatedFilesSituation.forEach(\r\n                (fileInfo, fileIndex) => {\r\n                    \r\n                    if(fileInfo.hasPiece){//the piece in this square is candidate for having possible moves\r\n                        let pieceId = fileInfo.pieceId;\r\n                        let pieceName = fileInfo.pieceName;\r\n                        let pieceColor = fileInfo.pieceColor;\r\n                        let pieceMoves = fileInfo.pieceMoves;\r\n                        let pieceRank = fileInfo.positionOnBoard.rankNumber;\r\n                        let pieceFile = fileInfo.positionOnBoard.fileNumber;\r\n                        let moves = [];\r\n\r\n                        if(pieceName === 'Pawn' && pieceColor === 'white'){//START PAWN POSSIBLE MOVES GENERATION\r\n                            if(isLayoutDefault){\r\n                                //the pawn can move two squares infront on condition that it has not been moved before and that square has no piece and the square before it has no piece\r\n                                if(pieceMoves === 0 \r\n                                    && !chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex].hasPiece \r\n                                    && !chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex -2].rankNumber}.${chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                    ];\r\n                                }\r\n                                //the pawn can move a square infront on condition that the square exists and it doesn't have a piece\r\n                                if(chessboardSituation[rankIndex - 1] \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex] \r\n                                    && !chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex-1].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                    ];\r\n                                }\r\n\r\n                                //the pawn can move a square in the front rank and any of the front side files on condition that those squares exist and they have a black piece\r\n                                if((chessboardSituation[rankIndex - 1] \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1] \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].hasPiece) \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].pieceColor === 'black'){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].fileNumber}.X`\r\n                                    ];\r\n                                }\r\n                                if((chessboardSituation[rankIndex - 1] \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1] \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].hasPiece) \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].pieceColor === 'black'){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].fileNumber}.X`\r\n                                    ];\r\n                                }\r\n\r\n                                //the pawn can capture a black pawn en passant on condition that the white pawn is in rank index 3 and the to be captured pawn\r\n                                //is in an adjacent file and it just moved there\r\n                                //left\r\n                                if(rankIndex === 3\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1]\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceName === 'Pawn'\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceMoves === 1){\r\n                                        //check if the pawn adjacent to the potential en passant capturer is the last thing moved there\r\n                                        if(history[history.length - 1][history[history.length - 1].length -1].id ===  chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceId){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].fileNumber}.E.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceId}`\r\n                                            ];\r\n                                        }\r\n                                    }\r\n                                //right\r\n                                if(rankIndex === 3\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1]\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceName === 'Pawn'\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceMoves === 1){\r\n                                        //check if the pawn adjacent to the potential en passant capturer is the last thing moved there\r\n                                        if(history[history.length - 1][history[history.length - 1].length -1].id ===  chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceId){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].fileNumber}.E.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceId}`\r\n                                            ];\r\n                                        }\r\n                                    }\r\n\r\n                            }else{\r\n                                //the pawn can move two squares infront on condition that it has not been moved before and that square has no piece\r\n                                if(pieceMoves === 0 \r\n                                    && !chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex].hasPiece \r\n                                    && !chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex +2].rankNumber}.${chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                    ];\r\n                                }\r\n                                 //the pawn can move a square infront on condition that the square exists and it doesn't have a piece\r\n                                 if(chessboardSituation[rankIndex + 1] \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex] \r\n                                    && !chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex+1].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                    ];\r\n                                }\r\n                                //the pawn can move a square in the front rank and any of the front side files on condition that those squares exist and they have a black piece\r\n                                if((chessboardSituation[rankIndex + 1] \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1] \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].hasPiece) \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].pieceColor === 'black'){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].fileNumber}.X`\r\n                                    ];\r\n                                }\r\n                                if((chessboardSituation[rankIndex + 1] \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1] \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].hasPiece) \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].pieceColor === 'black'){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].fileNumber}.X`\r\n                                    ];\r\n                                }\r\n\r\n                                //the pawn can capture a black pawn en passant on condition that the white pawn is in rank index 4 and the to be captured pawn\r\n                                //is in an adjacent file and it just moved there\r\n                                //left\r\n                                if(rankIndex === 4\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1]\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceName === 'Pawn'\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceMoves === 1){\r\n                                        //check if the pawn adjacent to the potential en passant capturer is the last thing moved there\r\n                                        if(history[history.length - 1][history[history.length - 1].length -1].id ===  chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceId){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].fileNumber}.E.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceId}`\r\n                                            ];\r\n                                        }\r\n                                    }\r\n                                //right\r\n                                if(rankIndex === 4\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1]\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceName === 'Pawn'\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceMoves === 1){\r\n                                        //check if the pawn adjacent to the potential en passant capturer is the last thing moved there\r\n                                        if(history[history.length - 1][history[history.length - 1].length -1].id ===  chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceId){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].fileNumber}.E.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceId}`\r\n                                            ];\r\n                                        }\r\n                                    }\r\n                            }\r\n\r\n                            possibleMoves = [\r\n                                ...possibleMoves, \r\n                                {\r\n                                    pieceId,\r\n                                    pieceName,\r\n                                    pieceColor,\r\n                                    pieceMoves,\r\n                                    pieceFile,\r\n                                    pieceRank,\r\n                                    moves,\r\n                                }\r\n                            ];\r\n    \r\n                            moves = [];\r\n                        }else if(pieceName === 'Pawn' && pieceColor === 'black'){\r\n                            if(!isLayoutDefault){\r\n                                //the pawn can move two squares infront on condition that it has not been moved before and that square has no piece\r\n                                if(pieceMoves === 0 \r\n                                    && !chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex].hasPiece \r\n                                    && !chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex -2].rankNumber}.${chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                    ];\r\n                                }\r\n                                //the pawn can move a square infront on condition that the square exists and it doesn't have a piece\r\n                                if(chessboardSituation[rankIndex - 1] \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex] \r\n                                    && !chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex-1].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                    ];\r\n                                }\r\n                                //the pawn can move a square in the front rank and any of the front side files on condition that those squares exist and they have a black piece\r\n                                if((chessboardSituation[rankIndex - 1] \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1] \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].hasPiece) \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].pieceColor === 'white'){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].fileNumber}.X`\r\n                                    ];\r\n                                }\r\n                                if((chessboardSituation[rankIndex - 1] \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1] \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].hasPiece) \r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].pieceColor === 'white'){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].fileNumber}.X`\r\n                                    ];\r\n                                }\r\n\r\n                                //the pawn can capture a white pawn en passant on condition that the black pawn is in rank index 3 and the to be captured pawn\r\n                                //is in an adjacent file and it just moved there\r\n                                //left\r\n                                if(rankIndex === 3\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1]\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceName === 'Pawn'\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceMoves === 1){\r\n                                        //check if the pawn adjacent to the potential en passant capturer is the last thing moved there\r\n                                        if(history[history.length - 1][history[history.length - 1].length -1].id ===  chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceId){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].fileNumber}.E.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceId}`\r\n                                            ];\r\n                                        }\r\n                                    }\r\n                                //right\r\n                                if(rankIndex === 3\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1]\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceName === 'Pawn'\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceMoves === 1){\r\n                                        //check if the pawn adjacent to the potential en passant capturer is the last thing moved there\r\n                                        if(history[history.length - 1][history[history.length - 1].length -1].id ===  chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceId){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].fileNumber}.E.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceId}`\r\n                                            ];\r\n                                        }\r\n                                    }\r\n                            }else{\r\n                                //the pawn can move two squares infront on condition that it has not been moved before and that square has no piece\r\n                                if(pieceMoves === 0 \r\n                                    && !chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex].hasPiece \r\n                                    && !chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex +2].rankNumber}.${chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                    ];\r\n                                }\r\n                                 //the pawn can move a square infront on condition that the square exists and it doesn't have a piece\r\n                                 if(chessboardSituation[rankIndex + 1] \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex] \r\n                                    && !chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex+1].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                    ];\r\n                                }\r\n                                //the pawn can move a square any of the front side files on condition that those squares exist and they have a black piece\r\n                                if((chessboardSituation[rankIndex + 1] \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1] \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].hasPiece) \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].pieceColor === 'white'){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].fileNumber}.X`\r\n                                    ];\r\n                                }\r\n                                if((chessboardSituation[rankIndex + 1] \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1] \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].hasPiece) \r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].pieceColor === 'white'){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].fileNumber}.X`\r\n                                    ];\r\n                                }\r\n\r\n                                //the pawn can capture a white pawn en passant on condition that the black pawn is in rank index 4 and the to be captured pawn\r\n                                //is in an adjacent file and it just moved there\r\n                                //left\r\n                                if(rankIndex === 4\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1]\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceName === 'Pawn'\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceMoves === 1){\r\n                                        //check if the pawn adjacent to the potential en passant capturer is the last thing moved there\r\n                                        if(history[history.length - 1][history[history.length - 1].length -1].id ===  chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceId){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].fileNumber}.E.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceId}`\r\n                                            ];\r\n                                        }\r\n                                    }\r\n                                //right\r\n                                if(rankIndex === 4\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1]\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceName === 'Pawn'\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceMoves === 1){\r\n                                        //check if the pawn adjacent to the potential en passant capturer is the last thing moved there\r\n                                        if(history[history.length - 1][history[history.length - 1].length -1].id ===  chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceId){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].fileNumber}.E.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceId}`\r\n                                            ];\r\n                                        }\r\n                                    }\r\n                            }\r\n\r\n                            possibleMoves = [\r\n                                ...possibleMoves, \r\n                                {\r\n                                    pieceId,\r\n                                    pieceName,\r\n                                    pieceColor,\r\n                                    pieceMoves,\r\n                                    pieceFile,\r\n                                    pieceRank,\r\n                                    moves,\r\n                                }\r\n                            ];\r\n    \r\n                            moves = [];\r\n                        }//END PAWN POSSIBLE MOVES GENERATION\r\n\r\n                        if(pieceName === 'Rook'){//START ROOK POSSIBLE MOVES GENERATION\r\n                            //upside\r\n                            if(rankIndex !== 0){\r\n                                //how far is the rook from the top of the board?\r\n                                let currentRank = rankIndex;\r\n                                while(currentRank !== 0){\r\n                                    currentRank--;\r\n                                    //if at any time the rook finds a piece of the same color as itself as it moves upwards, it cannot move any more\r\n                                    if(chessboardSituation[currentRank].associatedFilesSituation[fileIndex].hasPiece \r\n                                        && chessboardSituation[currentRank].associatedFilesSituation[fileIndex].pieceColor === pieceColor){\r\n                                        break;\r\n                                    }\r\n                                    //the rook can move to the next square upwards on condition that that square has no piece\r\n                                    if(!chessboardSituation[currentRank].associatedFilesSituation[fileIndex].hasPiece){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                        ];\r\n                                    }\r\n\r\n                                    //the rook can move to the next square upwards if the square is occupied by a piece of different color\r\n                                    //but the rook cannot move upwards any further after that\r\n                                    if(chessboardSituation[currentRank].associatedFilesSituation[fileIndex].hasPiece \r\n                                        && chessboardSituation[currentRank].associatedFilesSituation[fileIndex].pieceColor !== pieceColor){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[fileIndex].fileNumber}.X`\r\n                                        ];\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            //downside\r\n                            if(rankIndex !== 7){\r\n                                //how far is the rook from the bottom of the board?\r\n                                let currentRank = rankIndex;\r\n                                while(currentRank !== 7){\r\n                                    currentRank++;\r\n                                    //if at any time the rook finds a piece of the same color as itself as it moves downwards, it cannot move any more\r\n                                    if(chessboardSituation[currentRank].associatedFilesSituation[fileIndex].hasPiece \r\n                                        && chessboardSituation[currentRank].associatedFilesSituation[fileIndex].pieceColor === pieceColor){\r\n                                        break;\r\n                                    }\r\n                                    //the rook can move to the next square downwards on condition that that square has no piece\r\n                                    if(!chessboardSituation[currentRank].associatedFilesSituation[fileIndex].hasPiece){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                        ];\r\n                                    }\r\n\r\n                                    //the rook can move to the next square downwords if the square is occupied by a piece of different color\r\n                                    //but the rook cannot move downwords any further after that\r\n                                    if(chessboardSituation[currentRank].associatedFilesSituation[fileIndex].hasPiece \r\n                                        && chessboardSituation[currentRank].associatedFilesSituation[fileIndex].pieceColor !== pieceColor){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[fileIndex].fileNumber}.X`\r\n                                        ];\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            //leftside\r\n                            if(fileIndex !== 0){\r\n                                //how far is the rook from the left edge of the board?\r\n                                let currentFile = fileIndex;\r\n                                while(currentFile !== 0){\r\n                                    currentFile--;\r\n                                    //if at any time the rook finds a piece of the same color as itself as it moves towards the left, it cannot move any more\r\n                                    if(chessboardSituation[rankIndex].associatedFilesSituation[currentFile].hasPiece \r\n                                        && chessboardSituation[rankIndex].associatedFilesSituation[currentFile].pieceColor === pieceColor){\r\n                                        break;\r\n                                    }\r\n                                    //the rook can move to the next square towards the left on condition that that square has no piece\r\n                                    if(!chessboardSituation[rankIndex].associatedFilesSituation[currentFile].hasPiece){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[currentFile].fileNumber}`\r\n                                        ];\r\n                                    }\r\n\r\n                                    //the rook can move to the next square towards the side if the square is occupied by a piece of different color\r\n                                    //but the rook cannot move towards the side any further after that\r\n                                    if(chessboardSituation[rankIndex].associatedFilesSituation[currentFile].hasPiece \r\n                                        && chessboardSituation[rankIndex].associatedFilesSituation[currentFile].pieceColor !== pieceColor){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[currentFile].fileNumber}.X`\r\n                                        ];\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            //right side\r\n                            if(fileIndex !== 7){\r\n                                //how far is the rook from the right edge of the board?\r\n                                let currentFile = fileIndex;\r\n                                while(currentFile !== 7){\r\n                                    currentFile++;\r\n                                    //if at any time the rook finds a piece of the same color as itself as it moves towards the left, it cannot move any more\r\n                                    if(chessboardSituation[rankIndex].associatedFilesSituation[currentFile].hasPiece \r\n                                        && chessboardSituation[rankIndex].associatedFilesSituation[currentFile].pieceColor === pieceColor){\r\n                                        break;\r\n                                    }\r\n                                    //the rook can move to the next square towards the left on condition that that square has no piece\r\n                                    if(!chessboardSituation[rankIndex].associatedFilesSituation[currentFile].hasPiece){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[currentFile].fileNumber}`\r\n                                        ];\r\n                                    }\r\n\r\n                                    //the rook can move to the next square towards the side if the square is occupied by a piece of different color\r\n                                    //but the rook cannot move towards the side any further after that\r\n                                    if(chessboardSituation[rankIndex].associatedFilesSituation[currentFile].hasPiece \r\n                                        && chessboardSituation[rankIndex].associatedFilesSituation[currentFile].pieceColor !== pieceColor){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[currentFile].fileNumber}.X`\r\n                                        ];\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            possibleMoves = [\r\n                                ...possibleMoves, \r\n                                {\r\n                                    pieceId,\r\n                                    pieceName,\r\n                                    pieceColor,\r\n                                    pieceMoves,\r\n                                    pieceFile,\r\n                                    pieceRank,\r\n                                    moves,\r\n                                }\r\n                            ];\r\n    \r\n                            moves = [];\r\n\r\n                        }//END ROOK POSSIBLE MOVES GENERATION\r\n\r\n                        if(pieceName === 'Bishop'){//START BISHOP POSSIBLE MOVES GENERATION\r\n\r\n                            if(rankIndex !== 0){//if the bishop is not at the top of the board, we can generate main diagonal up or other diagonal up\r\n\r\n                                if(fileIndex !== 0){//we generate main diagonal up\r\n\r\n                                    //how far is the bishop from either rankIndex zero or fileIndex zero?\r\n                                    let currentRank = rankIndex;\r\n                                    let currentFile = fileIndex;\r\n\r\n                                    while(currentRank !== 0 && currentFile !== 0){\r\n                                        currentRank--;\r\n                                        currentFile--;\r\n\r\n                                        //if at any time the bishop finds a piece with the same color as itself while moving along main diagonal up, it cannot move any more\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor === pieceColor){\r\n                                            break;\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along main diagonal up provided that square has no piece\r\n                                        if(!chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}`\r\n                                            ];\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along main diagonal up if the square has an opponent piece\r\n                                        //however, after this, the bishop cannot move anymore\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor !== pieceColor){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}.X`\r\n                                            ];\r\n                                            break\r\n                                        }\r\n\r\n                                    }\r\n                                }\r\n\r\n                                if(fileIndex !== 7){//we generate other diagonal up\r\n                                    \r\n                                    //how far is the bishop from either rankIndex zero or fileIndex seven?\r\n                                    let currentRank = rankIndex;\r\n                                    let currentFile = fileIndex;\r\n\r\n                                    while(currentRank !== 0 && currentFile !== 7){\r\n                                        currentRank--;\r\n                                        currentFile++;\r\n\r\n                                        //if at any time the bishop finds a piece with the same color as itself while moving along other diagonal up, it cannot move any more\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor === pieceColor){\r\n                                            break;\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along other diagonal up provided that square has no piece\r\n                                        if(!chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}`\r\n                                            ];\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along other diagonal up if the square has an opponent piece\r\n                                        //however, after this, the bishop cannot move anymore\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor !== pieceColor){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}.X`\r\n                                            ];\r\n                                            break\r\n                                        }\r\n\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(rankIndex !== 7){//if the bishop is not at the bottom of the board, we can generate main diagonal down or other diagonal down\r\n\r\n                                if(fileIndex !== 0){//we generate other diagonal down\r\n\r\n                                    //how far is the bishop from either rankIndex seven or fileIndex zero?\r\n                                    let currentRank = rankIndex;\r\n                                    let currentFile = fileIndex;\r\n\r\n                                    while(currentRank !== 7 && currentFile !== 0){\r\n                                        currentRank++;\r\n                                        currentFile--;\r\n\r\n                                        //if at any time the bishop finds a piece with the same color as itself while moving along main diagonal up, it cannot move any more\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor === pieceColor){\r\n                                            break;\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along main diagonal up provided that square has no piece\r\n                                        if(!chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}`\r\n                                            ];\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along main diagonal up if the square has an opponent piece\r\n                                        //however, after this, the bishop cannot move anymore\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor !== pieceColor){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}.X`\r\n                                            ];\r\n                                            break\r\n                                        }\r\n\r\n                                    }\r\n                                }\r\n\r\n                                if(fileIndex !== 7){//we generate main diagonal down\r\n                                    \r\n                                    //how far is the bishop from either rankIndex seven or fileIndex seven?\r\n                                    let currentRank = rankIndex;\r\n                                    let currentFile = fileIndex;\r\n\r\n                                    while(currentRank !== 7 && currentFile !== 7){\r\n                                        currentRank++;\r\n                                        currentFile++;\r\n\r\n                                        //if at any time the bishop finds a piece with the same color as itself while moving along other diagonal up, it cannot move any more\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor === pieceColor){\r\n                                            break;\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along other diagonal up provided that square has no piece\r\n                                        if(!chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}`\r\n                                            ];\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along other diagonal up if the square has an opponent piece\r\n                                        //however, after this, the bishop cannot move anymore\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor !== pieceColor){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}.X`\r\n                                            ];\r\n                                            break\r\n                                        }\r\n\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            possibleMoves = [\r\n                                ...possibleMoves, \r\n                                {\r\n                                    pieceId,\r\n                                    pieceName,\r\n                                    pieceColor,\r\n                                    pieceMoves,\r\n                                    pieceFile,\r\n                                    pieceRank,\r\n                                    moves,\r\n                                }\r\n                            ];\r\n    \r\n                            moves = [];\r\n\r\n                        }//END BISHOP POSSIBLE MOVES GENERATION\r\n\r\n                        if(pieceName === 'Queen'){//START QUEEN POSSIBLE MOVES GENERATION\r\n                            \r\n                            //the queen behaves like a combination of the rook and the bishop\r\n                            //CODE PASTED DIRECTLY. comments may not be relevant to the queen. Planning on changing this\r\n                            //THE ROOK::\r\n                            //upside\r\n                            if(rankIndex !== 0){\r\n                                //how far is the rook from the top of the board?\r\n                                let currentRank = rankIndex;\r\n                                while(currentRank !== 0){\r\n                                    currentRank--;\r\n                                    //if at any time the rook finds a piece of the same color as itself as it moves upwards, it cannot move any more\r\n                                    if(chessboardSituation[currentRank].associatedFilesSituation[fileIndex].hasPiece \r\n                                        && chessboardSituation[currentRank].associatedFilesSituation[fileIndex].pieceColor === pieceColor){\r\n                                        break;\r\n                                    }\r\n                                    //the rook can move to the next square upwards on condition that that square has no piece\r\n                                    if(!chessboardSituation[currentRank].associatedFilesSituation[fileIndex].hasPiece){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                        ];\r\n                                    }\r\n\r\n                                    //the rook can move to the next square upwards if the square is occupied by a piece of different color\r\n                                    //but the rook cannot move upwards any further after that\r\n                                    if(chessboardSituation[currentRank].associatedFilesSituation[fileIndex].hasPiece \r\n                                        && chessboardSituation[currentRank].associatedFilesSituation[fileIndex].pieceColor !== pieceColor){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[fileIndex].fileNumber}.X`\r\n                                        ];\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            //downside\r\n                            if(rankIndex !== 7){\r\n                                //how far is the rook from the bottom of the board?\r\n                                let currentRank = rankIndex;\r\n                                while(currentRank !== 7){\r\n                                    currentRank++;\r\n                                    //if at any time the rook finds a piece of the same color as itself as it moves downwards, it cannot move any more\r\n                                    if(chessboardSituation[currentRank].associatedFilesSituation[fileIndex].hasPiece \r\n                                        && chessboardSituation[currentRank].associatedFilesSituation[fileIndex].pieceColor === pieceColor){\r\n                                        break;\r\n                                    }\r\n                                    //the rook can move to the next square downwards on condition that that square has no piece\r\n                                    if(!chessboardSituation[currentRank].associatedFilesSituation[fileIndex].hasPiece){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                        ];\r\n                                    }\r\n\r\n                                    //the rook can move to the next square downwords if the square is occupied by a piece of different color\r\n                                    //but the rook cannot move downwords any further after that\r\n                                    if(chessboardSituation[currentRank].associatedFilesSituation[fileIndex].hasPiece \r\n                                        && chessboardSituation[currentRank].associatedFilesSituation[fileIndex].pieceColor !== pieceColor){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[fileIndex].fileNumber}.X`\r\n                                        ];\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            //leftside\r\n                            if(fileIndex !== 0){\r\n                                //how far is the rook from the left edge of the board?\r\n                                let currentFile = fileIndex;\r\n                                while(currentFile !== 0){\r\n                                    currentFile--;\r\n                                    //if at any time the rook finds a piece of the same color as itself as it moves towards the left, it cannot move any more\r\n                                    if(chessboardSituation[rankIndex].associatedFilesSituation[currentFile].hasPiece \r\n                                        && chessboardSituation[rankIndex].associatedFilesSituation[currentFile].pieceColor === pieceColor){\r\n                                        break;\r\n                                    }\r\n                                    //the rook can move to the next square towards the left on condition that that square has no piece\r\n                                    if(!chessboardSituation[rankIndex].associatedFilesSituation[currentFile].hasPiece){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[currentFile].fileNumber}`\r\n                                        ];\r\n                                    }\r\n\r\n                                    //the rook can move to the next square towards the side if the square is occupied by a piece of different color\r\n                                    //but the rook cannot move towards the side any further after that\r\n                                    if(chessboardSituation[rankIndex].associatedFilesSituation[currentFile].hasPiece \r\n                                        && chessboardSituation[rankIndex].associatedFilesSituation[currentFile].pieceColor !== pieceColor){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[currentFile].fileNumber}.X`\r\n                                        ];\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            //right side\r\n                            if(fileIndex !== 7){\r\n                                //how far is the rook from the right edge of the board?\r\n                                let currentFile = fileIndex;\r\n                                while(currentFile !== 7){\r\n                                    currentFile++;\r\n                                    //if at any time the rook finds a piece of the same color as itself as it moves towards the left, it cannot move any more\r\n                                    if(chessboardSituation[rankIndex].associatedFilesSituation[currentFile].hasPiece \r\n                                        && chessboardSituation[rankIndex].associatedFilesSituation[currentFile].pieceColor === pieceColor){\r\n                                        break;\r\n                                    }\r\n                                    //the rook can move to the next square towards the left on condition that that square has no piece\r\n                                    if(!chessboardSituation[rankIndex].associatedFilesSituation[currentFile].hasPiece){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[currentFile].fileNumber}`\r\n                                        ];\r\n                                    }\r\n\r\n                                    //the rook can move to the next square towards the side if the square is occupied by a piece of different color\r\n                                    //but the rook cannot move towards the side any further after that\r\n                                    if(chessboardSituation[rankIndex].associatedFilesSituation[currentFile].hasPiece \r\n                                        && chessboardSituation[rankIndex].associatedFilesSituation[currentFile].pieceColor !== pieceColor){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[currentFile].fileNumber}.X`\r\n                                        ];\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            //END THE ROOK::\r\n\r\n                            //THE BISHOP::\r\n                            if(rankIndex !== 0){//if the bishop is not at the top of the board, we can generate main diagonal up or other diagonal up\r\n\r\n                                if(fileIndex !== 0){//we generate main diagonal up\r\n\r\n                                    //how far is the bishop from either rankIndex zero or fileIndex zero?\r\n                                    let currentRank = rankIndex;\r\n                                    let currentFile = fileIndex;\r\n\r\n                                    while(currentRank !== 0 && currentFile !== 0){\r\n                                        currentRank--;\r\n                                        currentFile--;\r\n\r\n                                        //if at any time the bishop finds a piece with the same color as itself while moving along main diagonal up, it cannot move any more\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor === pieceColor){\r\n                                            break;\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along main diagonal up provided that square has no piece\r\n                                        if(!chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}`\r\n                                            ];\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along main diagonal up if the square has an opponent piece\r\n                                        //however, after this, the bishop cannot move anymore\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor !== pieceColor){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}.X`\r\n                                            ];\r\n                                            break\r\n                                        }\r\n\r\n                                    }\r\n                                }\r\n\r\n                                if(fileIndex !== 7){//we generate other diagonal up\r\n                                    \r\n                                    //how far is the bishop from either rankIndex zero or fileIndex seven?\r\n                                    let currentRank = rankIndex;\r\n                                    let currentFile = fileIndex;\r\n\r\n                                    while(currentRank !== 0 && currentFile !== 7){\r\n                                        currentRank--;\r\n                                        currentFile++;\r\n\r\n                                        //if at any time the bishop finds a piece with the same color as itself while moving along other diagonal up, it cannot move any more\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor === pieceColor){\r\n                                            break;\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along other diagonal up provided that square has no piece\r\n                                        if(!chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}`\r\n                                            ];\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along other diagonal up if the square has an opponent piece\r\n                                        //however, after this, the bishop cannot move anymore\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor !== pieceColor){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}.X`\r\n                                            ];\r\n                                            break\r\n                                        }\r\n\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(rankIndex !== 7){//if the bishop is not at the bottom of the board, we can generate main diagonal down or other diagonal down\r\n\r\n                                if(fileIndex !== 0){//we generate other diagonal down\r\n\r\n                                    //how far is the bishop from either rankIndex seven or fileIndex zero?\r\n                                    let currentRank = rankIndex;\r\n                                    let currentFile = fileIndex;\r\n\r\n                                    while(currentRank !== 7 && currentFile !== 0){\r\n                                        currentRank++;\r\n                                        currentFile--;\r\n\r\n                                        //if at any time the bishop finds a piece with the same color as itself while moving along main diagonal up, it cannot move any more\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor === pieceColor){\r\n                                            break;\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along main diagonal up provided that square has no piece\r\n                                        if(!chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}`\r\n                                            ];\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along main diagonal up if the square has an opponent piece\r\n                                        //however, after this, the bishop cannot move anymore\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor !== pieceColor){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}.X`\r\n                                            ];\r\n                                            break\r\n                                        }\r\n\r\n                                    }\r\n                                }\r\n\r\n                                if(fileIndex !== 7){//we generate main diagonal down\r\n                                    \r\n                                    //how far is the bishop from either rankIndex seven or fileIndex seven?\r\n                                    let currentRank = rankIndex;\r\n                                    let currentFile = fileIndex;\r\n\r\n                                    while(currentRank !== 7 && currentFile !== 7){\r\n                                        currentRank++;\r\n                                        currentFile++;\r\n\r\n                                        //if at any time the bishop finds a piece with the same color as itself while moving along other diagonal up, it cannot move any more\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor === pieceColor){\r\n                                            break;\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along other diagonal up provided that square has no piece\r\n                                        if(!chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}`\r\n                                            ];\r\n                                        }\r\n\r\n                                        //the bishop can move to the next square along other diagonal up if the square has an opponent piece\r\n                                        //however, after this, the bishop cannot move anymore\r\n                                        if(chessboardSituation[currentRank].associatedFilesSituation[currentFile].hasPiece \r\n                                            && chessboardSituation[currentRank].associatedFilesSituation[currentFile].pieceColor !== pieceColor){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[currentRank].rankNumber}.${chessboardSituation[currentRank].associatedFilesSituation[currentFile].fileNumber}.X`\r\n                                            ];\r\n                                            break\r\n                                        }\r\n\r\n                                    }\r\n                                }\r\n                            }\r\n                            //END THE BISHOP::\r\n\r\n                            possibleMoves = [\r\n                                ...possibleMoves, \r\n                                {\r\n                                    pieceId,\r\n                                    pieceName,\r\n                                    pieceColor,\r\n                                    pieceMoves,\r\n                                    pieceFile,\r\n                                    pieceRank,\r\n                                    moves,\r\n                                }\r\n                            ];\r\n    \r\n                            moves = [];\r\n                            \r\n                        }//END QUEEN POSSIBLE MOVES GENERATION\r\n\r\n                        if(pieceName === 'Knight'){//START KNIGHT POSSIBLE MOVES GENERATION\r\n                            //the knight moves in a combination of either two ranks and a file beside(up or down)\r\n                            //or two files and a rank beneath or above(left or right)\r\n\r\n                            //up\r\n                            //up left\r\n                            if(chessboardSituation[rankIndex - 2]\r\n                                && chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex - 1]\r\n                                && !chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex - 1].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 2].rankNumber}.${chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex - 1].fileNumber}`\r\n                                    ];\r\n                            }\r\n                            if(chessboardSituation[rankIndex - 2]\r\n                                && chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex - 1]\r\n                                && chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                                && chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex - 1].pieceColor !== pieceColor){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 2].rankNumber}.${chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex - 1].fileNumber}.X`\r\n                                    ];\r\n                            }\r\n                            //up right\r\n                            if(chessboardSituation[rankIndex - 2]\r\n                                && chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex + 1]\r\n                                && !chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex + 1].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 2].rankNumber}.${chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex + 1].fileNumber}`\r\n                                    ];\r\n                            }\r\n                            if(chessboardSituation[rankIndex - 2]\r\n                                && chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex + 1]\r\n                                && chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                                && chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex + 1].pieceColor !== pieceColor){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 2].rankNumber}.${chessboardSituation[rankIndex - 2].associatedFilesSituation[fileIndex + 1].fileNumber}.X`\r\n                                    ];\r\n                            }\r\n\r\n                            //down\r\n                            //down left\r\n                            if(chessboardSituation[rankIndex + 2]\r\n                                && chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex - 1]\r\n                                && !chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex - 1].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 2].rankNumber}.${chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex - 1].fileNumber}`\r\n                                    ];\r\n                            }\r\n                            if(chessboardSituation[rankIndex + 2]\r\n                                && chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex - 1]\r\n                                && chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                                && chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex - 1].pieceColor !== pieceColor){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 2].rankNumber}.${chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex - 1].fileNumber}.X`\r\n                                    ];\r\n                            }\r\n                            //down right\r\n                            if(chessboardSituation[rankIndex + 2]\r\n                                && chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex + 1]\r\n                                && !chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex + 1].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 2].rankNumber}.${chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex + 1].fileNumber}`\r\n                                    ];\r\n                            }\r\n                            if(chessboardSituation[rankIndex + 2]\r\n                                && chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex + 1]\r\n                                && chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                                && chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex + 1].pieceColor !== pieceColor){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 2].rankNumber}.${chessboardSituation[rankIndex + 2].associatedFilesSituation[fileIndex + 1].fileNumber}.X`\r\n                                    ];\r\n                            }\r\n\r\n                            //left\r\n                            //left up\r\n                            if(chessboardSituation[rankIndex - 1]\r\n                                && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 2]\r\n                                && !chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 2].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 2].fileNumber}`\r\n                                    ];\r\n                            }\r\n                            if(chessboardSituation[rankIndex - 1]\r\n                                && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 2]\r\n                                && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 2].hasPiece\r\n                                && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 2].pieceColor !== pieceColor){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 2].fileNumber}.X`\r\n                                    ];\r\n                            }\r\n\r\n                            //left down\r\n                            if(chessboardSituation[rankIndex + 1]\r\n                                && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 2]\r\n                                && !chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 2].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 2].fileNumber}`\r\n                                    ];\r\n                            }\r\n                            if(chessboardSituation[rankIndex + 1]\r\n                                && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 2]\r\n                                && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 2].hasPiece\r\n                                && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 2].pieceColor !== pieceColor){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 2].fileNumber}.X`\r\n                                    ];\r\n                            }\r\n\r\n                            //right\r\n                            //right up\r\n                            if(chessboardSituation[rankIndex - 1]\r\n                                && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 2]\r\n                                && !chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 2].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 2].fileNumber}`\r\n                                    ];\r\n                            }\r\n                            if(chessboardSituation[rankIndex - 1]\r\n                                && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 2]\r\n                                && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 2].hasPiece\r\n                                && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 2].pieceColor !== pieceColor){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 2].fileNumber}.X`\r\n                                    ];\r\n                            }\r\n\r\n                            //right down\r\n                            if(chessboardSituation[rankIndex + 1]\r\n                                && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 2]\r\n                                && !chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 2].hasPiece){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 2].fileNumber}`\r\n                                    ];\r\n                            }\r\n                            if(chessboardSituation[rankIndex + 1]\r\n                                && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 2]\r\n                                && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 2].hasPiece\r\n                                && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 2].pieceColor !== pieceColor){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 2].fileNumber}.X`\r\n                                    ];\r\n                            }\r\n\r\n                            possibleMoves = [\r\n                                ...possibleMoves, \r\n                                {\r\n                                    pieceId,\r\n                                    pieceName,\r\n                                    pieceColor,\r\n                                    pieceMoves,\r\n                                    pieceFile,\r\n                                    pieceRank,\r\n                                    moves,\r\n                                }\r\n                            ];\r\n    \r\n                            moves = [];\r\n                        }//END KNIGHT POSSIBLE MOVES GENERATION\r\n\r\n                        //hasPiece is here\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    );\r\n\r\n    return possibleMoves;\r\n}","import {determineChessboardSituation} from './BoardLogic';\r\nimport {generatePossibleMoves} from './PiecesLogic';\r\n\r\n//this function generates possible moves for the king\r\n//it also tracks the safety of the king based on possible moves of other pieces\r\n//it returns the possible moves of the kings and a boolean that tracks situations when either of the kings is in danger\r\n\r\nexport const kingTracker = (possibleMoves, chessboardSituation, isLayoutDefault) => {\r\n    let kingInfo = [];\r\n    let kingPossibleMoves = [];\r\n    let isKingInCheck = {status:false, id:null, attackers: []};\r\n\r\n    chessboardSituation.forEach(\r\n        (rankInfo, rankIndex) => {\r\n            rankInfo.associatedFilesSituation.forEach(\r\n                (fileInfo, fileIndex) => {\r\n                    if(fileInfo.hasPiece && fileInfo.pieceName === 'King'){//we generate possible moves for this piece\r\n                        let pieceId = fileInfo.pieceId;\r\n                        let pieceColor = fileInfo.pieceColor;\r\n                        let pieceMoves = fileInfo.pieceMoves;\r\n                        let pieceRank = fileInfo.positionOnBoard.rankNumber;\r\n                        let pieceFile = fileInfo.positionOnBoard.fileNumber;\r\n                        let moves = [];\r\n\r\n\r\n                        let attackers = [];//save the ids of the attackers of the king\r\n                        //is the king in check?\r\n                        possibleMoves.forEach(\r\n                            (piece, pieceIndex) => {\r\n                                piece.moves.forEach(\r\n                                    (move, moveId) => {\r\n                                       if(piece.pieceName !== 'Pawn'){\r\n                                            if(move.substring(0,3) === `${rankInfo.rankNumber}.${fileInfo.fileNumber}`\r\n                                            && piece.pieceColor !== fileInfo.pieceColor){\r\n                                                isKingInCheck = {status:true, id:fileInfo.pieceId, attackers: [...attackers, piece.pieceId]};\r\n                                            }\r\n                                       }else{\r\n                                            if(move.substring(0,3) === `${rankInfo.rankNumber}.${fileInfo.fileNumber}`\r\n                                            && piece.pieceColor !== fileInfo.pieceColor && move.search(\"X\") !== -1){\r\n                                                isKingInCheck = {status:true, id:fileInfo.pieceId, attackers: [...attackers, piece.pieceId]};\r\n                                            }\r\n                                       }\r\n                                    }\r\n                                );\r\n                            }\r\n                        );\r\n\r\n                        //a king can move a single square in any direction provided that square exists, \r\n                        //has no piece and is not a possible move for an opponent piece\r\n\r\n                        //for cases where the opponent piece is a pawn, a king can be able to move in front of the pawn\r\n                        //even though the square is among the pawn's possible moves\r\n\r\n\r\n                        //up the board\r\n                        if(chessboardSituation[rankIndex - 1]\r\n                            && !chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex].hasPiece){\r\n                                //check if this square is under attack by an opponent piece\r\n                                let isUnderPressure = false;\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                       piece.moves.forEach(\r\n                                           (move, moveIndex) => {\r\n                                                if(move.substring(0,3) === `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex].fileNumber}` \r\n                                                && piece.pieceColor !== pieceColor\r\n                                                && piece.pieceName !== 'Pawn'){\r\n                                                    isUnderPressure = true;\r\n                                                }\r\n                                           }\r\n                                       );\r\n                                    }\r\n                                );\r\n\r\n                                if(!isUnderPressure){\r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                    ];\r\n                                }\r\n\r\n                            }\r\n\r\n                            //up the board left\r\n                            if(chessboardSituation[rankIndex - 1]\r\n                                && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1]\r\n                                && !chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].hasPiece){\r\n                                    //check if this square is under attack by an opponent piece\r\n                                    let isUnderPressure = false;\r\n                                    possibleMoves.forEach(\r\n                                        (piece, pieceIndex) => {\r\n                                        piece.moves.forEach(\r\n                                            (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].fileNumber}` \r\n                                                    && piece.pieceColor !== pieceColor\r\n                                                    && piece.pieceName !== 'Pawn'){\r\n                                                        isUnderPressure = true;\r\n                                                    }\r\n                                            }\r\n                                        );\r\n                                        }\r\n                                    );\r\n\r\n                                    if(!isUnderPressure){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].fileNumber}`\r\n                                        ];\r\n                                    }\r\n\r\n                                }\r\n\r\n                                //up the board right\r\n                                if(chessboardSituation[rankIndex - 1]\r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1]\r\n                                    && !chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].hasPiece){\r\n                                        //check if this square is under attack by an opponent piece\r\n                                        let isUnderPressure = false;\r\n                                        possibleMoves.forEach(\r\n                                            (piece, pieceIndex) => {\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                        if(move.substring(0,3) === `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].fileNumber}` \r\n                                                        && piece.pieceColor !== pieceColor\r\n                                                        && piece.pieceName !== 'Pawn'){\r\n                                                            isUnderPressure = true;\r\n                                                        }\r\n                                                }\r\n                                            );\r\n                                            }\r\n                                        );\r\n\r\n                                        if(!isUnderPressure){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].fileNumber}`\r\n                                            ];\r\n                                        }\r\n\r\n                                    }\r\n\r\n                            //down the board\r\n                            if(chessboardSituation[rankIndex + 1]\r\n                                && !chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex].hasPiece){\r\n                                    //check if this square is under attack by an opponent piece\r\n                                    let isUnderPressure = false;\r\n                                    possibleMoves.forEach(\r\n                                        (piece, pieceIndex) => {\r\n                                        piece.moves.forEach(\r\n                                            (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex].fileNumber}` \r\n                                                    && piece.pieceColor !== pieceColor\r\n                                                    && piece.pieceName !== 'Pawn'){\r\n                                                        isUnderPressure = true;\r\n                                                    }\r\n                                            }\r\n                                        );\r\n                                        }\r\n                                    );\r\n\r\n                                    if(!isUnderPressure){\r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex].fileNumber}`\r\n                                        ];\r\n                                    }\r\n\r\n                                }\r\n\r\n                                //down the board left\r\n                                if(chessboardSituation[rankIndex + 1]\r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1]\r\n                                    && !chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].hasPiece){\r\n                                        //check if this square is under attack by an opponent piece\r\n                                        let isUnderPressure = false;\r\n                                        possibleMoves.forEach(\r\n                                            (piece, pieceIndex) => {\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                        if(move.substring(0,3) === `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].fileNumber}` \r\n                                                        && piece.pieceColor !== pieceColor\r\n                                                        && piece.pieceName !== 'Pawn'){\r\n                                                            isUnderPressure = true;\r\n                                                        }\r\n                                                }\r\n                                            );\r\n                                            }\r\n                                        );\r\n\r\n                                        if(!isUnderPressure){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].fileNumber}`\r\n                                            ];\r\n                                        }\r\n\r\n                                    }\r\n\r\n                                    //up the board right\r\n                                    if(chessboardSituation[rankIndex + 1]\r\n                                        && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1]\r\n                                        && !chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].hasPiece){\r\n                                            //check if this square is under attack by an opponent piece\r\n                                            let isUnderPressure = false;\r\n                                            possibleMoves.forEach(\r\n                                                (piece, pieceIndex) => {\r\n                                                piece.moves.forEach(\r\n                                                    (move, moveIndex) => {\r\n                                                            if(move.substring(0,3) === `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].fileNumber}` \r\n                                                            && piece.pieceColor !== pieceColor\r\n                                                            && piece.pieceName !== 'Pawn'){\r\n                                                                isUnderPressure = true;\r\n                                                            }\r\n                                                    }\r\n                                                );\r\n                                                }\r\n                                            );\r\n\r\n                                            if(!isUnderPressure){\r\n                                                moves = [\r\n                                                    ...moves,\r\n                                                    `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].fileNumber}`\r\n                                                ];\r\n                                            }\r\n\r\n                                        }\r\n\r\n                                 //towards the left\r\n                                if(chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1]\r\n                                    && !chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].hasPiece){\r\n                                        //check if this square is under attack by an opponent piece\r\n                                        let isUnderPressure = false;\r\n                                        possibleMoves.forEach(\r\n                                            (piece, pieceIndex) => {\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                        if(move.substring(0,3) === `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].fileNumber}` \r\n                                                        && piece.pieceColor !== pieceColor\r\n                                                        && piece.pieceName !== 'Pawn'){\r\n                                                            isUnderPressure = true;\r\n                                                        }\r\n                                                }\r\n                                            );\r\n                                            }\r\n                                        );\r\n\r\n                                        if(!isUnderPressure){\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].fileNumber}`\r\n                                            ];\r\n                                        }\r\n\r\n                                    }\r\n\r\n                                      //towards the right\r\n                                    if(chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1]\r\n                                        && !chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].hasPiece){\r\n                                            //check if this square is under attack by an opponent piece\r\n                                            let isUnderPressure = false;\r\n                                            possibleMoves.forEach(\r\n                                                (piece, pieceIndex) => {\r\n                                                piece.moves.forEach(\r\n                                                    (move, moveIndex) => {\r\n                                                            if(move.substring(0,3) === `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].fileNumber}` \r\n                                                            && piece.pieceColor !== pieceColor\r\n                                                            && piece.pieceName !== 'Pawn'){\r\n                                                                isUnderPressure = true;\r\n                                                            }\r\n                                                    }\r\n                                                );\r\n                                                }\r\n                                            );\r\n\r\n                                            if(!isUnderPressure){\r\n                                                moves = [\r\n                                                    ...moves,\r\n                                                    `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].fileNumber}`\r\n                                                ];\r\n                                            }\r\n\r\n                                        }\r\n\r\n                        \r\n                        //CAPTURES\r\n                        //a king can capture an opponent piece from any direction provided that square exists, \r\n                        // and has an opponent piece \r\n\r\n                        //up the board\r\n                        if(chessboardSituation[rankIndex - 1]\r\n                            && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex].hasPiece\r\n                            && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex].pieceColor !== pieceColor){ \r\n                               \r\n                                moves = [\r\n                                    ...moves,\r\n                                    `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex].fileNumber}.X`\r\n                                ];\r\n                            }\r\n\r\n                            //up the board left\r\n                            if(chessboardSituation[rankIndex - 1]\r\n                                && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1]\r\n                                && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                                && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].pieceColor !== pieceColor){\r\n                                    \r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].fileNumber}.X`\r\n                                    ];\r\n                                }\r\n\r\n                                //up the board right\r\n                                if(chessboardSituation[rankIndex - 1]\r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1]\r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                                    && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].pieceColor !== pieceColor){\r\n                                                           \r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex - 1].rankNumber}.${chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].fileNumber}.X`\r\n                                        ];\r\n                                    }\r\n\r\n                            //down the board\r\n                            if(chessboardSituation[rankIndex + 1]\r\n                                && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex].hasPiece\r\n                                && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex].pieceColor !== pieceColor){\r\n                                    \r\n                                    moves = [\r\n                                        ...moves,\r\n                                        `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex].fileNumber}.X`\r\n                                    ];\r\n                                }\r\n\r\n                                //down the board left\r\n                                if(chessboardSituation[rankIndex + 1]\r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1]\r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                                    && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].pieceColor !== pieceColor){\r\n                                                                        \r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].fileNumber}.X`\r\n                                        ];\r\n                                    }\r\n\r\n                                    //up the board right\r\n                                    if(chessboardSituation[rankIndex + 1]\r\n                                        && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1]\r\n                                        && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                                        && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].pieceColor !== pieceColor){\r\n                                        \r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex + 1].rankNumber}.${chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].fileNumber}.X`\r\n                                            ];\r\n                                        }\r\n\r\n                                 //towards the left\r\n                                if(chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1]\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                                    && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceColor !== pieceColor){\r\n                                    \r\n                                        moves = [\r\n                                            ...moves,\r\n                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].fileNumber}.X`\r\n                                        ];\r\n                                    }\r\n\r\n                                      //towards the right\r\n                                    if(chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1]\r\n                                        && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                                        && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceColor !== pieceColor){\r\n\r\n                                            moves = [\r\n                                                ...moves,\r\n                                                `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].fileNumber}.X`\r\n                                            ];\r\n                                        }\r\n\r\n                    \r\n                                        //CASTLING\r\n                                        //can the king castle?\r\n                                        //castling short\r\n                                        if(isLayoutDefault){\r\n                                            //castling short is always towards the right\r\n                                            if(pieceMoves === 0\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1]\r\n                                                && !chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 2]\r\n                                                && !chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 2].hasPiece\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 3]\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 3].pieceName === 'Rook'\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 3].pieceColor === pieceColor\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 3].pieceMoves === 0){\r\n                                                   //check if this square is under attack by an opponent piece\r\n                                                    let isUnderPressure = false;\r\n                                                    possibleMoves.forEach(\r\n                                                        (piece, pieceIndex) => {\r\n                                                        piece.moves.forEach(\r\n                                                            (move, moveIndex) => {\r\n                                                                    if((move.substring(0,3) === `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].fileNumber}`\r\n                                                                    ||move.substring(0,3) === `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 2].fileNumber}`) \r\n                                                                    && piece.pieceColor !== pieceColor){\r\n                                                                        isUnderPressure = true;\r\n                                                                    }\r\n                                                            }\r\n                                                        );\r\n                                                        }\r\n                                                    );\r\n\r\n                                                    if(!isUnderPressure){\r\n                                                        moves = [\r\n                                                            ...moves,\r\n                                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 2].fileNumber}.Cs.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 3].pieceId}`\r\n                                                        ];\r\n                                                    }\r\n                                                }\r\n                                        }else{\r\n                                            if(pieceMoves === 0\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1]\r\n                                                && !chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 2]\r\n                                                && !chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 2].hasPiece\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 3]\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 3].pieceName === 'Rook'\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 3].pieceColor === pieceColor\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 3].pieceMoves === 0){\r\n                                                    //check if this square is under attack by an opponent piece\r\n                                                    let isUnderPressure = false;\r\n                                                    possibleMoves.forEach(\r\n                                                        (piece, pieceIndex) => {\r\n                                                        piece.moves.forEach(\r\n                                                            (move, moveIndex) => {\r\n                                                                    if((move.substring(0,3) === `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].fileNumber}`\r\n                                                                    ||move.substring(0,3) === `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 2].fileNumber}`) \r\n                                                                    && piece.pieceColor !== pieceColor){\r\n                                                                        isUnderPressure = true;\r\n                                                                    }\r\n                                                            }\r\n                                                        );\r\n                                                        }\r\n                                                    );\r\n                                                    if(!isUnderPressure){\r\n                                                        moves = [\r\n                                                            ...moves,\r\n                                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 2].fileNumber}.Cs.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 3].pieceId}`\r\n                                                        ];\r\n                                                    }\r\n                                                }\r\n                                        }\r\n\r\n                                        //castling long\r\n                                        if(!isLayoutDefault){\r\n                                            //castling long is always towards the right\r\n                                            if(pieceMoves === 0\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1]\r\n                                                && !chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 2]\r\n                                                && !chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 2].hasPiece\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 3]\r\n                                                && !chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 3].hasPiece\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 4]\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 4].pieceName === 'Rook'\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 4].pieceColor === pieceColor\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 4].pieceMoves === 0){\r\n                                                    let isUnderPressure = false;\r\n                                                    possibleMoves.forEach(\r\n                                                        (piece, pieceIndex) => {\r\n                                                        piece.moves.forEach(\r\n                                                            (move, moveIndex) => {\r\n                                                                    if((move.substring(0,3) === `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].fileNumber}`\r\n                                                                    ||move.substring(0,3) === `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 2].fileNumber}`\r\n                                                                    ||move.substring(0,3) === `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 3].fileNumber}`) \r\n                                                                    && piece.pieceColor !== pieceColor){\r\n                                                                        isUnderPressure = true;\r\n                                                                    }\r\n                                                            }\r\n                                                        );\r\n                                                        }\r\n                                                    );\r\n                                                    if(!isUnderPressure){\r\n                                                        moves = [\r\n                                                            ...moves,\r\n                                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 2].fileNumber}.Cl.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 4].pieceId}`\r\n                                                        ];\r\n                                                    }\r\n                                                }\r\n                                        }else{\r\n                                            if(pieceMoves === 0\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1]\r\n                                                && !chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 2]\r\n                                                && !chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 2].hasPiece\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 3]\r\n                                                && !chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 3].hasPiece\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 4]\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 4].pieceName === 'Rook'\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 4].pieceColor === pieceColor\r\n                                                && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 4].pieceMoves === 0){\r\n                                                    //check if this square is under attack by an opponent piece\r\n                                                    let isUnderPressure = false;\r\n                                                    possibleMoves.forEach(\r\n                                                        (piece, pieceIndex) => {\r\n                                                        piece.moves.forEach(\r\n                                                            (move, moveIndex) => {\r\n                                                                    if((move.substring(0,3) === `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].fileNumber}`\r\n                                                                    ||move.substring(0,3) === `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 2].fileNumber}`\r\n                                                                    ||move.substring(0,3) === `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 3].fileNumber}`) \r\n                                                                    && piece.pieceColor !== pieceColor){\r\n                                                                        isUnderPressure = true;\r\n                                                                    }\r\n                                                            }\r\n                                                        );\r\n                                                        }\r\n                                                    );\r\n                                                    if(!isUnderPressure){\r\n                                                        moves = [\r\n                                                            ...moves,\r\n                                                            `${chessboardSituation[rankIndex].rankNumber}.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 2].fileNumber}.Cl.${chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 4].pieceId}`\r\n                                                        ];\r\n                                                    }\r\n                                                }\r\n                                        }\r\n\r\n                                        kingPossibleMoves = [\r\n                                            ...kingPossibleMoves, \r\n                                            {\r\n                                                pieceName: 'King',\r\n                                                pieceId,\r\n                                                pieceColor,\r\n                                                pieceMoves,\r\n                                                pieceFile,\r\n                                                pieceRank,\r\n                                                positionOnBoard: {\r\n                                                    rankNumber: pieceRank,\r\n                                                    fileNumber: pieceFile\r\n                                                },\r\n                                                moves,\r\n                                            }\r\n                                        ];\r\n                \r\n                                        moves = [];\r\n\r\n                        //piece is king is here\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    );\r\n\r\n    kingInfo[0] = isKingInCheck;\r\n    kingInfo[1] = kingPossibleMoves;\r\n\r\n    return kingInfo;\r\n}\r\n\r\n//this function will refine the king possible moves to ensure that the kings\r\n//cannot get a square adjacent to each other \r\nexport const refineKingMoves = (kingPossibleMoves) => {\r\n    let newKingPossibleMoves = [];\r\n\r\n    let firstKingMoves = [];\r\n    let secondKingMoves = [];\r\n\r\n    let initialFirst = kingPossibleMoves[0].moves;\r\n    let initialOther = kingPossibleMoves[1].moves;\r\n\r\n    initialFirst.forEach(\r\n        (move, moveIndex) => {\r\n            if(!initialOther.includes(move)){\r\n                firstKingMoves.push(move);\r\n            }\r\n        }\r\n    );\r\n\r\n    initialOther.forEach(\r\n        (move, moveIndex) => {\r\n            if(!initialFirst.includes(move)){\r\n                secondKingMoves.push(move);\r\n            }\r\n        }\r\n    );\r\n    \r\n\r\n    newKingPossibleMoves.push({...kingPossibleMoves[0], moves:firstKingMoves});\r\n    newKingPossibleMoves.push({...kingPossibleMoves[1], moves:secondKingMoves});\r\n\r\n    return newKingPossibleMoves;\r\n}\r\n\r\n//this function puts the king moves generated by both king tracker and refine king moves\r\n//to a final test. It ensures these moves are legitimate king moves for the current situation\r\nexport const canMyKingBeHere = (move, currentPieceInfo, chessboardLayout, isLayoutDefault, history, kingColor) => {\r\n\r\n    let kingCanBeHere = true;\r\n    //get the rank and file in question from the king moves\r\n    let targetRank = parseInt(move.substring(0,1));\r\n    let targetFile = parseInt(move.substring(2,3));\r\n\r\n    //from the piece information, let the piece at the target rank and file, if any\r\n    //be captured\r\n\r\n    //again from the piece information, change the position of the king in question to\r\n    //the target rank and target file\r\n    let copyPieceInfo = JSON.parse(JSON.stringify(currentPieceInfo));\r\n\r\n    currentPieceInfo.forEach(\r\n        (piece, pieceIndex) => {\r\n            if(piece.positionOnBoard.rankNumber === targetRank && piece.positionOnBoard.fileNumber === targetFile){\r\n                if(!piece.hasBeenCaptured){\r\n                    copyPieceInfo[pieceIndex].hasBeenCaptured = true;\r\n                }\r\n            }\r\n\r\n            if(piece.pieceName === 'King' && piece.pieceColor === kingColor){\r\n                copyPieceInfo[pieceIndex].positionOnBoard.rankNumber = targetRank;\r\n                copyPieceInfo[pieceIndex].positionOnBoard.fileNumber = targetFile;\r\n            }\r\n        }\r\n    );\r\n\r\n    //create a chessboard array that will be used to generate a situation\r\n    let chessboardInfo = [];\r\n    let associatedFilesHolder = [];\r\n\r\n    //first form a chessboard array (an array of 8 members with each member having an array property with 8 members 8X8)\r\n    for(let currentRank = 0; currentRank < 8; currentRank++){\r\n\r\n        //prepare an array that holds info about the files associated with current rank\r\n        for(let fileCounter = 0; fileCounter < 8; fileCounter++){\r\n       \r\n            associatedFilesHolder = [\r\n                ...associatedFilesHolder,\r\n                {\r\n                    fileNumber: chessboardLayout.fileNumbers[fileCounter],\r\n                    fileName: chessboardLayout.filesPlacement[fileCounter],\r\n                }\r\n            ];\r\n        }\r\n\r\n        chessboardInfo = [\r\n            ...chessboardInfo,\r\n            {\r\n                rankNumber: chessboardLayout.ranksPlacement[currentRank],\r\n                associatedFiles: [\r\n                    ...associatedFilesHolder\r\n                ]\r\n            }\r\n        ];\r\n\r\n        associatedFilesHolder = [];\r\n    }\r\n\r\n    //create a situation based on these info\r\n    const chessboardSituation = determineChessboardSituation(chessboardInfo, copyPieceInfo);\r\n    //generate possible moves based on this situation\r\n    let possibleMoves = generatePossibleMoves(chessboardSituation, isLayoutDefault, history);\r\n\r\n    //if the king's position is a possible move for any of the pieces(but the forward going pawn),\r\n    //then the king cannot be there\r\n    possibleMoves.forEach(\r\n        (piece, pieceIndex) => {\r\n            if(piece.pieceName !== 'Pawn'){\r\n                piece.moves.forEach(\r\n                    (move, moveIndex) => {\r\n                        if(move.substring(0,3) === `${targetRank}.${targetFile}`){\r\n                            kingCanBeHere = false;\r\n                        }\r\n                    }\r\n                );\r\n            }else{\r\n                piece.moves.forEach(\r\n                    (move, moveIndex) => {\r\n                        if(move.substring(0,3) === `${targetRank}.${targetFile}` && move.search(\"X\") !== -1){\r\n                            kingCanBeHere = false;\r\n                        }\r\n                    }\r\n                );\r\n            }\r\n        }\r\n    );\r\n\r\n     //if the king is next to the other king, then this situation shuould never happen on the board\r\n     chessboardSituation.forEach(\r\n        (rankInfo, rankIndex) => {\r\n            rankInfo.associatedFilesSituation.forEach(\r\n                (fileInfo, fileIndex) => {\r\n                    if(fileInfo.hasPiece && fileInfo.pieceName === 'King' && fileInfo.pieceColor !== kingColor){\r\n                        //up the board\r\n                        if(chessboardSituation[rankIndex - 1]\r\n                            && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex]\r\n                            && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex].hasPiece\r\n                            && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex].pieceName === 'King'){\r\n                                kingCanBeHere = false;\r\n                            }\r\n\r\n                         //down the board\r\n                         if(chessboardSituation[rankIndex + 1]\r\n                            && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex]\r\n                            && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex].hasPiece\r\n                            && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex].pieceName === 'King'){\r\n                                kingCanBeHere = false;\r\n                            }\r\n\r\n                        //left of the board\r\n                        if(chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1]\r\n                            && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                            && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex - 1].pieceName === 'King'){\r\n                                kingCanBeHere = false;\r\n                            }\r\n\r\n                        //right of the board\r\n                        if(chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1]\r\n                            && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                            && chessboardSituation[rankIndex].associatedFilesSituation[fileIndex + 1].pieceName === 'King'){\r\n                                kingCanBeHere = false;\r\n                            }\r\n                        \r\n                        //first diagonal up\r\n                        if(chessboardSituation[rankIndex - 1]\r\n                            && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1 ]\r\n                            && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                            && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex - 1].pieceName === 'King'){\r\n                                kingCanBeHere = false;\r\n                            }\r\n\r\n                        //other diagonal up\r\n                        if(chessboardSituation[rankIndex - 1]\r\n                            && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1 ]\r\n                            && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                            && chessboardSituation[rankIndex - 1].associatedFilesSituation[fileIndex + 1].pieceName === 'King'){\r\n                                kingCanBeHere = false;\r\n                            }\r\n\r\n                         //first diagonal down\r\n                         if(chessboardSituation[rankIndex + 1]\r\n                            && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1 ]\r\n                            && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].hasPiece\r\n                            && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex - 1].pieceName === 'King'){\r\n                                kingCanBeHere = false;\r\n                            }\r\n\r\n                        //other diagonal down\r\n                        if(chessboardSituation[rankIndex + 1]\r\n                            && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1 ]\r\n                            && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].hasPiece\r\n                            && chessboardSituation[rankIndex + 1].associatedFilesSituation[fileIndex + 1].pieceName === 'King'){\r\n                                kingCanBeHere = false;\r\n                            }\r\n                        \r\n\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    );\r\n\r\n    return kingCanBeHere;\r\n\r\n}","\r\n\r\n//this function is going to decide the possible squares for a piece trying to defend its king\r\nexport const canMyPieceHelp = (attackerInfo, kingInfo, possibleMoves, numberOfAttackers) => {\r\n    let possibleSquares = [];\r\n    if(numberOfAttackers === 1){\r\n         //we are going to inspect every possible move of the piece in question and examine\r\n        //the move's potential to solve the check\r\n        possibleMoves.forEach(\r\n            (move, moveIndex) => {\r\n                let potentialRank = parseInt(move.substring(0,1));\r\n                let potentialFile = parseInt(move.substring(2,3));\r\n\r\n                //the piece can solve the check if it can capture the attacker\r\n                if(attackerInfo.rankNumber === potentialRank && attackerInfo.fileNumber === potentialFile){\r\n                    possibleSquares = [\r\n                        ...possibleSquares,\r\n                        move,\r\n                    ];\r\n                }\r\n\r\n                //the piece can solve the check if it can block the path between the attacker and the king\r\n                let kingRank = kingInfo.rankNumber;\r\n                let kingFile = kingInfo.fileNumber;\r\n\r\n                //I assumed a default chessboard layout to comment, but the logic should work with any of the layouts\r\n\r\n\r\n                //VERTICAL BLOCKAGE\r\n                //king is up the board and attacker down\r\n                if(kingFile === attackerInfo.fileNumber \r\n                    && kingRank - attackerInfo.rankNumber > 1\r\n                    && kingFile === potentialFile){\r\n                    //if potential rank is in between, then the piece can intercept\r\n                    let canIntercept = false;\r\n                    if(kingRank > potentialRank && potentialRank >  attackerInfo.rankNumber){\r\n                        canIntercept = true;\r\n                    }\r\n                    if(canIntercept){\r\n                        possibleSquares = [\r\n                            ...possibleSquares,\r\n                            move,\r\n                        ];\r\n                    }\r\n                }\r\n                //king is down the board and attacker up\r\n                if(kingFile === attackerInfo.fileNumber \r\n                    && attackerInfo.rankNumber - kingRank > 1\r\n                    && kingFile === potentialFile){\r\n                    //if potential rank is in between, then the piece can intercept\r\n                    let canIntercept = false;\r\n                    if( attackerInfo.rankNumber > potentialRank && potentialRank > kingRank){\r\n                        canIntercept = true;\r\n                    }\r\n                    if(canIntercept){\r\n                        possibleSquares = [\r\n                            ...possibleSquares,\r\n                            move,\r\n                        ];\r\n                    }\r\n                }\r\n\r\n                //HORIZONTAL BLOCKAGE\r\n                //the king is on the left of the attacker\r\n                if(kingRank === attackerInfo.rankNumber\r\n                    && kingRank === potentialRank\r\n                    && attackerInfo.fileNumber - kingFile > 1){\r\n                        let canIntercept = false;\r\n                        if(potentialFile > kingFile && attackerInfo.fileNumber > potentialFile){\r\n                            canIntercept = true;\r\n                        }\r\n                        if(canIntercept){\r\n                            possibleSquares = [\r\n                                ...possibleSquares,\r\n                                move,\r\n                            ];\r\n                        }\r\n                    }\r\n                //the king is on the right of the attacker\r\n                if(kingRank === attackerInfo.rankNumber\r\n                    && kingRank === potentialRank\r\n                    && kingFile - attackerInfo.fileNumber > 1){\r\n                        let canIntercept = false;\r\n                        if(kingFile > potentialFile && potentialFile > attackerInfo.fileNumber){\r\n                            canIntercept = true;\r\n                        }\r\n                        if(canIntercept){\r\n                            possibleSquares = [\r\n                                ...possibleSquares,\r\n                                move,\r\n                            ];\r\n                        }\r\n                    }\r\n\r\n\r\n                //DIAGONAL BLOCKAGE\r\n                if(kingRank !== attackerInfo.rankNumber\r\n                    && kingFile !== attackerInfo.fileNumber\r\n                    && kingRank !== potentialRank\r\n                    && kingFile !== potentialFile\r\n                    && potentialRank !== attackerInfo.rankNumber\r\n                    && potentialFile !== attackerInfo.fileNumber){\r\n\r\n                        //the king is on the upper side of the attacker\r\n                        // the king is on the upper side left of the attacker\r\n                        if(kingRank - attackerInfo.rankNumber > 1\r\n                            && attackerInfo.fileNumber - kingFile > 1){\r\n                                if(kingRank > potentialRank \r\n                                    && potentialRank > attackerInfo.rankNumber\r\n                                    && potentialFile > kingFile\r\n                                    && attackerInfo.fileNumber >  potentialFile){\r\n                                        let canIntercept = false;\r\n                                        let rankCounter = kingRank;\r\n                                        let fileCounter = kingFile;\r\n                                        while(rankCounter !== attackerInfo.rankNumber && fileCounter !== attackerInfo.fileNumber){\r\n                                            if(rankCounter - potentialRank === 1 && potentialFile - fileCounter === 1){\r\n                                                canIntercept = true;\r\n                                                break;\r\n                                            }\r\n                                            rankCounter--;\r\n                                            fileCounter++;\r\n                                        }\r\n\r\n                                        if(canIntercept){\r\n                                            possibleSquares = [\r\n                                                ...possibleSquares,\r\n                                                move,\r\n                                            ];\r\n                                        }\r\n                                }\r\n                            }\r\n                        // the king is on the upper side right of the attacker\r\n                        if(kingRank - attackerInfo.rankNumber > 1\r\n                            && kingFile - attackerInfo.fileNumber > 1){\r\n                                if(kingRank > potentialRank \r\n                                    && potentialRank > attackerInfo.rankNumber\r\n                                    && kingFile > potentialFile\r\n                                    && potentialFile >  attackerInfo.fileNumber){\r\n                                        let canIntercept = false;\r\n                                        let rankCounter = kingRank;\r\n                                        let fileCounter = kingFile;\r\n                                        while(rankCounter !== attackerInfo.rankNumber && fileCounter !== attackerInfo.fileNumber){\r\n                                            if(rankCounter - potentialRank === 1 && fileCounter - potentialFile === 1){\r\n                                                canIntercept = true;\r\n                                                break;\r\n                                            }\r\n                                            rankCounter--;\r\n                                            fileCounter--;\r\n                                        }\r\n\r\n                                        if(canIntercept){\r\n                                            possibleSquares = [\r\n                                                ...possibleSquares,\r\n                                                move,\r\n                                            ];\r\n                                        }\r\n                                }\r\n                            }\r\n\r\n\r\n                        //the king is on the lower side of the attacker\r\n                        // the king is on the lower side left of the attacker\r\n                        if(attackerInfo.rankNumber - kingRank > 1\r\n                            && attackerInfo.fileNumber - kingFile > 1){\r\n                                if(potentialRank > kingRank\r\n                                    && attackerInfo.rankNumber > potentialRank\r\n                                    && potentialFile > kingFile\r\n                                    && attackerInfo.fileNumber >  potentialFile){\r\n                                        let canIntercept = false;\r\n                                        let rankCounter = attackerInfo.rankNumber;\r\n                                        let fileCounter = attackerInfo.fileNumber;\r\n                                        while(rankCounter !== kingRank && fileCounter !== kingFile){\r\n                                            if(rankCounter - potentialRank === 1 && fileCounter - potentialFile === 1){\r\n                                                canIntercept = true;\r\n                                                break;\r\n                                            }\r\n                                            rankCounter--;\r\n                                            fileCounter--;\r\n                                        }\r\n\r\n                                        if(canIntercept){\r\n                                            possibleSquares = [\r\n                                                ...possibleSquares,\r\n                                                move,\r\n                                            ];\r\n                                        }\r\n                                }\r\n                            }\r\n                        // the king is on the lower side right of the attacker\r\n                        if(attackerInfo.rankNumber - kingRank > 1\r\n                            && kingFile - attackerInfo.fileNumber > 1){\r\n                                if(potentialRank > kingRank\r\n                                    && attackerInfo.rankNumber > potentialRank\r\n                                    && kingFile > potentialFile\r\n                                    && potentialFile >  attackerInfo.fileNumber){\r\n                                        let canIntercept = false;\r\n                                        let rankCounter = attackerInfo.rankNumber;\r\n                                        let fileCounter = attackerInfo.fileNumber;\r\n                                        while(rankCounter !== kingRank && fileCounter !== kingFile){\r\n                                            if(rankCounter - potentialRank === 1 && potentialFile - fileCounter === 1){\r\n                                                canIntercept = true;\r\n                                                break;\r\n                                            }\r\n                                            rankCounter--;\r\n                                            fileCounter++;\r\n                                        }\r\n\r\n                                        if(canIntercept){\r\n                                            possibleSquares = [\r\n                                                ...possibleSquares,\r\n                                                move,\r\n                                            ];\r\n                                        }\r\n                                }\r\n                            }\r\n\r\n\r\n                    }\r\n\r\n\r\n            }\r\n        );\r\n    }\r\n\r\n    return possibleSquares;\r\n}\r\n\r\n","import {kingTracker} from './KingLogic';\r\nimport {generatePossibleMoves} from './PiecesLogic';\r\nimport {determineChessboardSituation} from './BoardLogic';\r\n\r\n\r\n//this function will tell the chessboard whether \r\n//a piece intending to be moved by a player is pinned or not\r\nexport const isMyPiecePinned = (targetRank, targetFile, chessboardSituation, isLayoutDefault, history, currentPieceInfo, turn) => {\r\n    let pieceIsPinned = false;\r\n    let copySituation = JSON.parse(JSON.stringify(chessboardSituation));\r\n\r\n    chessboardSituation.forEach(\r\n        (rankInfo, rankIndex) => {\r\n            if(rankInfo.rankNumber === targetRank){\r\n                rankInfo.associatedFilesSituation.forEach(\r\n                    (fileInfo, fileIndex) => {\r\n                        if(fileInfo.fileNumber === targetFile) {\r\n                            copySituation[rankIndex].associatedFilesSituation[fileIndex] = {\r\n                                hasPiece: false,\r\n                                fileNumber: fileInfo.fileNumber,\r\n                            }\r\n                        }\r\n                    }\r\n                );\r\n            }\r\n        }\r\n    );\r\n\r\n    //generate possible moves were the situation to be changed this way\r\n    let possibleMoves = generatePossibleMoves(copySituation, isLayoutDefault, history);\r\n    let isKingInCheck = kingTracker(possibleMoves, copySituation, isLayoutDefault);\r\n    if(isKingInCheck[0].status){\r\n        //check for the color of the king\r\n        currentPieceInfo.forEach(\r\n            (piece, pieceIndex) => {\r\n                if(piece.pieceId === isKingInCheck[0].id){\r\n                    if(piece.pieceColor === turn){\r\n                        pieceIsPinned = true;\r\n                    }\r\n                }\r\n            }\r\n        );\r\n    }\r\n    return pieceIsPinned;\r\n}\r\n\r\n//this function determines whether a move for a pinned piece is valid or not\r\n//the move is valid if it does not leave the king in check\r\nexport const canMyPieceBeHere = (pieceId, move, currentPieceInfo, chessboardLayout, isLayoutDefault, history) => {\r\n\r\n    let pieceCanBeHere = true;\r\n    //get the rank and file in question from the piece moves\r\n    let targetRank = parseInt(move.substring(0,1));\r\n    let targetFile = parseInt(move.substring(2,3));\r\n\r\n    //from the piece information, let the piece at the target rank and file, if any\r\n    //be captured\r\n\r\n    //again from the piece information, change the position of the piece in question to\r\n    //the target rank and target file\r\n    let copyPieceInfo = JSON.parse(JSON.stringify(currentPieceInfo));\r\n\r\n    currentPieceInfo.forEach(\r\n        (piece, pieceIndex) => {\r\n            if(piece.positionOnBoard.rankNumber === targetRank \r\n                && piece.positionOnBoard.fileNumber === targetFile \r\n                && piece.pieceId !== pieceId){\r\n                if(!piece.hasBeenCaptured){\r\n                    copyPieceInfo[pieceIndex].hasBeenCaptured = true;\r\n                } \r\n            }\r\n\r\n            if(piece.pieceId === pieceId){\r\n                copyPieceInfo[pieceIndex].positionOnBoard.rankNumber = targetRank;\r\n                copyPieceInfo[pieceIndex].positionOnBoard.fileNumber = targetFile;\r\n            }\r\n        }\r\n    );\r\n\r\n    //create a chessboard array that will be used to generate a situation\r\n    let chessboardInfo = [];\r\n    let associatedFilesHolder = [];\r\n\r\n    //first form a chessboard array (an array of 8 members with each member having an array property with 8 members 8X8)\r\n    for(let currentRank = 0; currentRank < 8; currentRank++){\r\n\r\n        //prepare an array that holds info about the files associated with current rank\r\n        for(let fileCounter = 0; fileCounter < 8; fileCounter++){\r\n       \r\n            associatedFilesHolder = [\r\n                ...associatedFilesHolder,\r\n                {\r\n                    fileNumber: chessboardLayout.fileNumbers[fileCounter],\r\n                    fileName: chessboardLayout.filesPlacement[fileCounter],\r\n                }\r\n            ];\r\n        }\r\n\r\n        chessboardInfo = [\r\n            ...chessboardInfo,\r\n            {\r\n                rankNumber: chessboardLayout.ranksPlacement[currentRank],\r\n                associatedFiles: [\r\n                    ...associatedFilesHolder\r\n                ]\r\n            }\r\n        ];\r\n\r\n        associatedFilesHolder = [];\r\n    }\r\n\r\n    //create a situation based on these info\r\n    const chessboardSituation = determineChessboardSituation(chessboardInfo, copyPieceInfo);\r\n    //generate possible moves based on this situation\r\n    let possibleMoves = generatePossibleMoves(chessboardSituation, isLayoutDefault, history);\r\n    //check if the king will be in check was this to be the case\r\n    let isKingInCheck = kingTracker(possibleMoves, chessboardSituation, isLayoutDefault);\r\n\r\n    if(isKingInCheck[0].status) pieceCanBeHere = false;\r\n\r\n\r\n    return pieceCanBeHere;\r\n}","import React, {\r\n    useReducer,\r\n    useState,\r\n    useEffect,\r\n} from 'react';\r\nimport King from './pieces/King';\r\nimport Queen from './pieces/Queen';\r\nimport Rook from './pieces/Rook';\r\nimport Bishop from './pieces/Bishop';\r\nimport Knight from './pieces/Knight';\r\nimport Pawn from './pieces/Pawn';\r\nimport {initialPieceInfo} from './info/PiecesInfo';\r\nimport {\r\n    createChessboardInfo,\r\n    determineChessboardSituation,\r\n} from './logic/BoardLogic';\r\nimport {generatePossibleMoves} from './logic/PiecesLogic';\r\nimport {kingTracker, refineKingMoves, canMyKingBeHere} from './logic/KingLogic';\r\nimport {canMyPieceHelp} from './logic/InCheckLogic';\r\nimport { isMyPiecePinned, canMyPieceBeHere } from './logic/PinLogic';\r\nimport '../styles/boardStyles.css';\r\n\r\n\r\n\r\n//this component represents the chess board visual and logic\r\n//scheduled to undergo numerous changes\r\n\r\n//the reducer function that transforms pieces\r\nconst transformPiece = (pieceSituation, action) => {\r\n    switch(action.type){\r\n        case 'UPDATE_PIECE_POSITION':\r\n            return action.value;\r\n        default:\r\n            return pieceSituation;\r\n    }\r\n}\r\n\r\n\r\nconst Chessboard = ({chessboardLayout, turn, switchTurn, changePromotionState, promotionPiece, setPromotionPiece, setScreenContent}) => \r\n{\r\n    //a state variable that will track whenever a checkmate occurs\r\n    const [checkmate, setCheckmate] = useState(false);\r\n\r\n    //a variable that will store the pieces information when the app is first loaded\r\n    const initialPiecesInfo = initialPieceInfo;\r\n\r\n    //state variable that will store the pieces information\r\n    const [currentPieceInfo, changePieceInfo] = useReducer(transformPiece, initialPiecesInfo);\r\n    // console.log(\"current piece information\", currentPieceInfo);\r\n\r\n    //state variable that will track the activity phase of the application\r\n    const [activityPhase, setActivityPhase] = useState(\r\n        {\r\n            pieceId: null,\r\n            from: null,\r\n            to: null,\r\n            isPiecePinned: null,\r\n        }\r\n    );\r\n    //      \r\n\r\n    //the reducer function that manipulates the chessboard color scheme\r\n    const manipulateColorScheme = (currentScheme, action) => {\r\n        switch(action.type){\r\n            case 'POSSIBLE_MOVES':\r\n                return({\r\n                    type: 'POSSIBLE_MOVES',\r\n                    isColorSchemeDefault: false,\r\n                    possibleSquares: action.possibleSquares,\r\n                    targetSquare: action.targetSquare,\r\n                    targetCheckSquare: action.targetCheckSquare,\r\n                });\r\n            case 'SHOW_CHECK':\r\n                return({\r\n                    type: 'SHOW_CHECK',\r\n                    isColorSchemeDefault: false,\r\n                    targetCheckSquare: action.targetCheckSquare,\r\n                });\r\n            case 'RETURN_TO_DEFAULT':\r\n                return({\r\n                    isColorSchemeDefault: true,\r\n                });\r\n            default:\r\n                return currentScheme;\r\n        }\r\n    }\r\n\r\n    //state variable that will determine the color scheme of the chessboard\r\n    const [colorScheme, setColorScheme] = useReducer(\r\n        manipulateColorScheme,\r\n        {\r\n            isColorSchemeDefault: true,\r\n        }\r\n    );\r\n \r\n    //a variable that will store the chessboard info when the app is first loaded\r\n    //or when a user changes the layout\r\n    const chessboardInfo = createChessboardInfo(chessboardLayout, colorScheme);\r\n    // console.log(\"chess board information\", chessboardInfo);\r\n\r\n    //a variable that captures the chessboardSituation currently\r\n    const chessboardSituation = determineChessboardSituation(chessboardInfo, currentPieceInfo);\r\n    // console.log(\"chess board situation\", chessboardSituation);\r\n\r\n    //a reducer method that will add a move to history\r\n    const addToHistory = (currentHistory, action) => {\r\n        switch(action.type){\r\n            case 'ADD_BLACK_MOVE':\r\n                let copy = currentHistory;\r\n                copy[currentHistory.length - 1].push(action.value);\r\n                return copy;\r\n            case 'ADD_WHITE_MOVE':\r\n                let newmove = [];\r\n                newmove = [...newmove, action.value];\r\n                return([\r\n                    ...currentHistory, newmove\r\n                ]);\r\n            default:\r\n                return currentHistory;\r\n        }\r\n    }\r\n    //a state variable that will hold an array of moves already made\r\n    const [history, updateHistory] = useReducer(addToHistory, []);\r\n    // console.log(\"history\", history);\r\n\r\n    //a variable that stores all possible moves for all the pieces inside the current chessboard situation\r\n    let possibleMoves = generatePossibleMoves(chessboardSituation, chessboardLayout.default, history);\r\n    //refine these possible moves\r\n    // const possibleMoves = refinePossibleMoves(rawPossibleMoves, chessboardSituation, chessboardLayout.default, history);\r\n    //get some info about the kings before display\r\n    let [isKingInCheck, rawKingPossibleMoves] = kingTracker(possibleMoves, chessboardSituation, chessboardLayout.default);\r\n    let intermediateKingPossibleMoves = refineKingMoves(rawKingPossibleMoves);\r\n    // console.log(\"king possible moves\", kingPossibleMoves);\r\n\r\n    //create a copy of the current piece info\r\n    let copyPieceInfo = currentPieceInfo;\r\n    let kingPossibleMoves = [];\r\n\r\n    intermediateKingPossibleMoves.forEach(\r\n        (king, kingIndex) => {\r\n            kingPossibleMoves = [\r\n                ...kingPossibleMoves,\r\n                {\r\n                    ...king,\r\n                    moves: []\r\n                }\r\n            ];\r\n\r\n            king.moves.forEach(\r\n                (move, moveIndex) => {\r\n                    let isSquareValid = canMyKingBeHere(move, copyPieceInfo, chessboardLayout, chessboardLayout.default, history, king.pieceColor);\r\n                    if(isSquareValid){\r\n                        kingPossibleMoves[kingIndex].moves = [\r\n                            ...kingPossibleMoves[kingIndex].moves, move\r\n                        ]\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    );\r\n   \r\n    possibleMoves.push(kingPossibleMoves[0]);\r\n    possibleMoves.push(kingPossibleMoves[1]);\r\n    // console.log(\"check info\", isKingInCheck);\r\n    // console.log(\"possible moves\", possibleMoves);\r\n\r\n    useEffect(\r\n        () => {\r\n            \r\n            //change the board's color scheme whenever a king is in check\r\n            if(isKingInCheck.status){\r\n                setScreenContent({\r\n                    message: 'Check!',\r\n                    verdict: '',\r\n                });\r\n\r\n                chessboardSituation.forEach(\r\n                    (rankInfo, rankIndex) => {\r\n                        rankInfo.associatedFilesSituation.forEach(\r\n                            (fileInfo, fileIndex) => {\r\n                                if(fileInfo.pieceId === isKingInCheck.id){\r\n                                    setColorScheme({type: 'SHOW_CHECK', targetCheckSquare: `${rankInfo.rankNumber}.${fileInfo.fileNumber}`,});\r\n                                    \r\n                                }\r\n                            }\r\n                        );\r\n                    }\r\n                );\r\n            }else{\r\n                setScreenContent({\r\n                    message: '',\r\n                    verdict: '',\r\n                });\r\n            }\r\n\r\n            //watch for checkmate\r\n            //if the king that is currently in check does not have moves, the chance for a checkmate on board is likely\r\n            let kingInDanger = {\r\n                moves: [0],\r\n            };\r\n            kingPossibleMoves.forEach(\r\n                (king, kingIndex) => {\r\n                    if(king.pieceId === isKingInCheck.id){\r\n                        kingInDanger = king;\r\n                    }\r\n                }\r\n            );\r\n\r\n            if(kingInDanger.moves.length === 0){\r\n                //we are going to check for a filtered version of possible moves for pieces of the king's\r\n                //Color, to determine whether the king has been checkmated\r\n\r\n                let kingCanBeSaved = false;\r\n                let attackerInfo;\r\n                let kingInfo;\r\n\r\n                //get the information of the king\r\n                //and the information of the attacker\r\n                currentPieceInfo.forEach(\r\n                    (piece, pieceIndex) => {\r\n                        if(piece.pieceId === isKingInCheck.attackers[0]){\r\n                            attackerInfo = piece.positionOnBoard;\r\n                        }\r\n                        if(piece.pieceId === isKingInCheck.id){\r\n                            kingInfo = piece.positionOnBoard;\r\n                        }\r\n                    }\r\n                );\r\n\r\n                possibleMoves.forEach(\r\n                    (piece, pieceIndex) => {\r\n                        if(piece.pieceColor === kingInDanger.pieceColor){\r\n                            let possibleSquares = canMyPieceHelp(attackerInfo, kingInfo, piece.moves, isKingInCheck.attackers.length);\r\n                            if(possibleSquares.length > 0){\r\n                                kingCanBeSaved = true;\r\n                            }\r\n                        }\r\n                    }\r\n                );\r\n\r\n                if(!kingCanBeSaved){\r\n                    setCheckmate(true);\r\n                }\r\n            }\r\n        },[turn]\r\n    );\r\n    \r\n    //check whether there is a pawn for promotion\r\n    useEffect(\r\n        () => {\r\n            //loop the current chessboard situation to see if there is a pawn on the eigth or the first rank\r\n            chessboardSituation.forEach(\r\n                (rankInfo, rankIndex) => {\r\n                    if(rankInfo.rankNumber ===  1 || rankInfo.rankNumber === 8){\r\n                        rankInfo.associatedFilesSituation.forEach(\r\n                            (fileInfo, fileIndex) => {\r\n                                if(fileInfo.hasPiece && fileInfo.pieceName === 'Pawn'){\r\n                                    \r\n                                    changePromotionState('block', fileInfo.pieceColor);\r\n                                    if(turn.color !== fileInfo.pieceColor){\r\n                                        switchTurn({type: 'CHANGE_COLOR'});\r\n                                    }\r\n                                }\r\n                            }\r\n                        );\r\n                    }\r\n                } \r\n            );\r\n\r\n        },[activityPhase]\r\n    );\r\n\r\n    //whenever there is a promotion piece, update the chessboard and return the promotion piece to null\r\n    useEffect(\r\n        () => {\r\n\r\n             //change the pieces when the promotion piece is set\r\n             if(promotionPiece){\r\n                let copyPieceInfo = currentPieceInfo;\r\n\r\n                currentPieceInfo.forEach(\r\n                    (piece,pieceIndex) => {\r\n                        if((piece.positionOnBoard.rankNumber === 1 || piece.positionOnBoard.rankNumber === 8)\r\n                        && piece.pieceColor === turn.color\r\n                        && piece.pieceName === 'Pawn'){\r\n                            copyPieceInfo[pieceIndex].pieceName = promotionPiece;\r\n                        }\r\n                    }\r\n                );\r\n                \r\n                changePieceInfo({type: 'UPDATE_PIECE_POSITION', value: copyPieceInfo});\r\n                switchTurn({type: 'CHANGE_COLOR'});\r\n                setPromotionPiece(null);\r\n            }\r\n\r\n            //a player cannot play elsewhere if he has to choose a piece\r\n             //loop the current chessboard situation to see if there is a pawn on the eigth or the first rank\r\n             chessboardSituation.forEach(\r\n                (rankInfo, rankIndex) => {\r\n                    if(rankInfo.rankNumber ===  1 || rankInfo.rankNumber === 8){\r\n                        rankInfo.associatedFilesSituation.forEach(\r\n                            (fileInfo, fileIndex) => {\r\n                                if(fileInfo.hasPiece && fileInfo.pieceName === 'Pawn'){\r\n                                    possibleMoves = [];\r\n                                }\r\n                            }\r\n                        );\r\n                    }\r\n                } \r\n            );\r\n        }\r\n    );\r\n\r\n    useEffect(\r\n        () => {\r\n            if(checkmate){\r\n\r\n                let kingId = isKingInCheck.id;\r\n                let kingColor;\r\n                \r\n                kingPossibleMoves.forEach(\r\n                    (king, kingIndex) => {\r\n                        if(king.pieceId === kingId){\r\n                            kingColor = king.pieceColor;\r\n                        }\r\n                    }\r\n                );\r\n                if(kingColor === 'white'){\r\n                    setScreenContent({\r\n                        message: '',\r\n                        verdict: 'Checkmate! Black wins...'\r\n                    });\r\n                }else{\r\n                    setScreenContent({\r\n                        message: '',\r\n                        verdict: 'Checkmate! White wins...'\r\n                    });\r\n                }\r\n            }\r\n        },[checkmate]\r\n    );\r\n\r\n\r\n    //callbacks\r\n    //handles action when a user makes an interaction with the chessboard\r\n    const launchPlayerActivity = (rankNumber, fileNumber, pieceInfo) => {\r\n        if(!checkmate){\r\n            if(!activityPhase.from && !activityPhase.to){\r\n                if(!isKingInCheck.status){\r\n                    //check whether the player is moving a piece of the turn's color\r\n                    if(turn.color === pieceInfo.color){\r\n    \r\n                        let possibleSquares = [];\r\n                        \r\n                        possibleMoves.forEach(\r\n                            (piece, pieceIndex) => {\r\n                                if(piece.pieceId === pieceInfo.id){\r\n                                    possibleSquares = piece.moves;\r\n                                }\r\n                            }\r\n                        );\r\n\r\n                        //check if the piece is pinned\r\n                        let myPieceIsPinned = isMyPiecePinned(rankNumber, fileNumber, chessboardSituation, chessboardLayout.default, history, currentPieceInfo, turn.color);\r\n                        if(myPieceIsPinned){\r\n                            \r\n                            //we need to investigate every move by a pinned piece to ensure the move will not leave the king in check\r\n                            let newPossibleSquares = [];\r\n                            possibleSquares.forEach(\r\n                                (move, moveIndex) => {\r\n                                    let isSquarePossible = canMyPieceBeHere(pieceInfo.id, move, currentPieceInfo, chessboardLayout, chessboardLayout.default, history);\r\n                                    if(isSquarePossible){\r\n                                        newPossibleSquares = [\r\n                                            ...newPossibleSquares,\r\n                                            move\r\n                                        ]\r\n                                    }\r\n                                }\r\n                            );\r\n\r\n                            possibleSquares = newPossibleSquares;\r\n                            \r\n                            setColorScheme({type: 'POSSIBLE_MOVES', targetSquare: `${rankNumber}.${fileNumber}`, possibleSquares,targetCheckSquare: null,});\r\n                            setActivityPhase({...activityPhase, from:  `${rankNumber}.${fileNumber}`, pieceId: pieceInfo.id, isPiecePinned: true,});\r\n                        }else{\r\n                            setColorScheme({type: 'POSSIBLE_MOVES', targetSquare: `${rankNumber}.${fileNumber}`, possibleSquares,targetCheckSquare: null,});\r\n                            setActivityPhase({...activityPhase, from:  `${rankNumber}.${fileNumber}`, pieceId: pieceInfo.id});\r\n                        }\r\n    \r\n                        \r\n                    }\r\n                }else{\r\n                    //check whether the player is moving a piece of the turn's color\r\n                    if(turn.color === pieceInfo.color){\r\n                        let possibleSquares = []\r\n                        //filter this piece's possible moves\r\n                        //allow only those that can help the king get out of check\r\n                        let myPossibleMoves;\r\n                        possibleMoves.forEach(\r\n                            (piece, pieceIndex) => {\r\n                                if(piece.pieceId === pieceInfo.id){\r\n                                    myPossibleMoves = piece.moves;\r\n                                }\r\n                            }\r\n                        );\r\n\r\n                        let kingInfo;\r\n                        let attackerInfo;\r\n\r\n                        //check if the piece is pinned\r\n                        let myPieceIsPinned = isMyPiecePinned(rankNumber, fileNumber, chessboardSituation, chessboardLayout.default, history, currentPieceInfo, turn.color);\r\n\r\n                        //get the information of the king\r\n                        //and the information of the attacker\r\n                        currentPieceInfo.forEach(\r\n                            (piece, pieceIndex) => {\r\n                                if(piece.pieceId === isKingInCheck.attackers[0]){\r\n                                    attackerInfo = piece.positionOnBoard;\r\n                                }\r\n                                if(piece.pieceId === isKingInCheck.id){\r\n                                    kingInfo = piece.positionOnBoard;\r\n                                }\r\n                            }\r\n                        );\r\n                       \r\n                      if(pieceInfo.piece !== 'King'){\r\n\r\n                        possibleSquares = canMyPieceHelp(attackerInfo, kingInfo, myPossibleMoves, isKingInCheck.attackers.length);\r\n                        \r\n                        \r\n                        if(myPieceIsPinned){\r\n                            //we need to investigate every move by a pinned piece to ensure the move will not leave the king in check\r\n                            let newPossibleSquares = [];\r\n                            possibleSquares.forEach(\r\n                                (move, moveIndex) => {\r\n                                    let isSquarePossible = canMyPieceBeHere(pieceInfo.id, move, currentPieceInfo, chessboardLayout, chessboardLayout.default, history);\r\n                                    if(isSquarePossible){\r\n                                        newPossibleSquares = [\r\n                                            ...newPossibleSquares,\r\n                                            move\r\n                                        ]\r\n                                    }\r\n                                }\r\n                            );\r\n\r\n                            possibleSquares = newPossibleSquares;\r\n                        }\r\n\r\n\r\n                      }else{\r\n                          possibleSquares = myPossibleMoves;\r\n                      }\r\n\r\n                        let targetCheckSquare;\r\n                        chessboardSituation.forEach(\r\n                            (rankInfo, rankIndex) => {\r\n                                rankInfo.associatedFilesSituation.forEach(\r\n                                    (fileInfo, fileIndex) => {\r\n                                        if(fileInfo.pieceId === isKingInCheck.id){\r\n                                            targetCheckSquare = `${rankInfo.rankNumber}.${fileInfo.fileNumber}`;\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n                        );\r\n    \r\n                       \r\n                        if(myPieceIsPinned){\r\n                            setColorScheme({type: 'POSSIBLE_MOVES', targetSquare: `${rankNumber}.${fileNumber}`, possibleSquares, targetCheckSquare,});\r\n                            setActivityPhase({...activityPhase, from:  `${rankNumber}.${fileNumber}`, pieceId: pieceInfo.id, isPiecePinned: true,});\r\n                        }else{\r\n                            setColorScheme({type: 'POSSIBLE_MOVES', targetSquare: `${rankNumber}.${fileNumber}`, possibleSquares, targetCheckSquare,});\r\n                            setActivityPhase({...activityPhase, from:  `${rankNumber}.${fileNumber}`, pieceId: pieceInfo.id});\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n    \r\n\r\n            if(activityPhase.from && !activityPhase.to){\r\n    \r\n                //the user clicked on an empty square, they want to move the from piece there\r\n                if(!pieceInfo.id){\r\n                    if(!isKingInCheck.status){\r\n                        let targetPiece = activityPhase.from;\r\n                        let currentPieces = currentPieceInfo;\r\n                        let isSquareWithinPossible = false;\r\n                        let isCaseEnPassant = false;\r\n                        let enPassantId = null;\r\n                        let isCaseCastlesShort = false;\r\n                        let isCaseCastlesLong = false;\r\n                        let castleId = null;\r\n\r\n                        //is the square within possible moves or an en passant square or maybe a castle?\r\n                        possibleMoves.forEach(\r\n                            (piece, pieceIndex) => {\r\n                                if(piece.pieceId === activityPhase.pieceId){\r\n                                   if(activityPhase.pieceId !== 15 && activityPhase.pieceId !== 16){\r\n                                        piece.moves.forEach(\r\n                                            (move, moveIndex) => {\r\n                                                if(move === `${rankNumber}.${fileNumber}`){\r\n                                                    if(activityPhase.isPiecePinned){\r\n                                                        //we need to check if the selected move is possible for a pinned piece\r\n                                                        let isSquarePossible = canMyPieceBeHere(activityPhase.pieceId, move, currentPieceInfo, chessboardLayout, chessboardLayout.default, history);\r\n                                                        if(isSquarePossible) isSquareWithinPossible = true;\r\n                                                    }else{\r\n                                                        isSquareWithinPossible = true;\r\n                                                    }\r\n                                                }\r\n                                                if(move.substring(0,3) === `${rankNumber}.${fileNumber}` && move.search(\"E\") !== -1){\r\n                                                    if(activityPhase.isPiecePinned){\r\n                                                        //we need to check if the selected move is possible for a pinned piece\r\n                                                        let isSquarePossible = canMyPieceBeHere(activityPhase.pieceId, move, currentPieceInfo, chessboardLayout, chessboardLayout.default, history);\r\n                                                        if(isSquarePossible){\r\n                                                            isCaseEnPassant = true;\r\n                                                            let moveInfo = move.split(\".\");\r\n                                                            enPassantId = parseInt(moveInfo[moveInfo.length - 1]);\r\n                                                        }\r\n                                                    }else{\r\n                                                        isCaseEnPassant = true;\r\n                                                        let moveInfo = move.split(\".\");\r\n                                                        enPassantId = parseInt(moveInfo[moveInfo.length - 1]);\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        );\r\n                                   }\r\n\r\n                                   if(activityPhase.pieceId === 15 || activityPhase.pieceId === 16){\r\n                                    piece.moves.forEach(\r\n                                        (move, moveIndex) => {\r\n                                            if(move === `${rankNumber}.${fileNumber}`){\r\n                                                isSquareWithinPossible = true;\r\n                                            }\r\n                                            if(move.substring(0,3) === `${rankNumber}.${fileNumber}` && move.search(\"Cs\") !== -1){\r\n                                                isCaseCastlesShort = true;\r\n                                                let moveInfo = move.split(\".\");\r\n                                                castleId = parseInt(moveInfo[moveInfo.length - 1]);\r\n                                            }\r\n                                            if(move.substring(0,3) === `${rankNumber}.${fileNumber}` && move.search(\"Cl\") !== -1){\r\n                                                isCaseCastlesLong = true;\r\n                                                let moveInfo = move.split(\".\");\r\n                                                castleId = parseInt(moveInfo[moveInfo.length - 1]);\r\n                                            }\r\n                                        }\r\n                                    );\r\n                                   }\r\n\r\n                                }\r\n                            }\r\n                        );\r\n                        \r\n                        if(isSquareWithinPossible){\r\n                            currentPieceInfo.forEach(\r\n                                (piece, pieceIndex) => {\r\n                                    if(`${piece.positionOnBoard.rankNumber}.${piece.positionOnBoard.fileNumber}` === targetPiece){\r\n                                        currentPieces[pieceIndex].positionOnBoard.rankNumber = rankNumber;\r\n                                        currentPieces[pieceIndex].positionOnBoard.fileNumber = fileNumber;\r\n                                        currentPieces[pieceIndex].noOfMoves = currentPieces[pieceIndex].noOfMoves + 1;\r\n                                    }\r\n                                }\r\n                            );\r\n\r\n                            changePieceInfo({type: 'UPDATE_PIECE_POSITION', value: currentPieces});\r\n                            // console.log(\"current pieces\", currentPieceInfo);\r\n                            setColorScheme({type: 'RETURN_TO_DEFAULT',});\r\n                            setActivityPhase({from: null, to: null, pieceId: null});\r\n\r\n                            if(turn.color === 'white'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_WHITE_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }else if(turn.color === 'black'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_BLACK_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n\r\n                            switchTurn({type: 'CHANGE_COLOR'});\r\n                        }else if(isCaseCastlesLong){\r\n                            currentPieceInfo.forEach(\r\n                                (piece, pieceIndex) => {\r\n                                    if(`${piece.positionOnBoard.rankNumber}.${piece.positionOnBoard.fileNumber}` === targetPiece){\r\n                                        currentPieces[pieceIndex].positionOnBoard.rankNumber = rankNumber;\r\n                                        currentPieces[pieceIndex].positionOnBoard.fileNumber = fileNumber;\r\n                                        currentPieces[pieceIndex].noOfMoves = currentPieces[pieceIndex].noOfMoves + 1;\r\n                                    }\r\n\r\n                                    if(piece.pieceId === castleId){\r\n                                        currentPieces[pieceIndex].positionOnBoard.fileNumber = fileNumber + 1;\r\n                                    }\r\n                                }\r\n                            );\r\n\r\n                            changePieceInfo({type: 'UPDATE_PIECE_POSITION', value: currentPieces});\r\n                            // console.log(\"current pieces\", currentPieceInfo);\r\n                            setColorScheme({type: 'RETURN_TO_DEFAULT',});\r\n                            setActivityPhase({from: null, to: null, pieceId: null});\r\n\r\n                            if(turn.color === 'white'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_WHITE_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }else if(turn.color === 'black'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_BLACK_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n\r\n                            switchTurn({type: 'CHANGE_COLOR'});\r\n\r\n                        }else if(isCaseCastlesShort){\r\n                            currentPieceInfo.forEach(\r\n                                (piece, pieceIndex) => {\r\n                                    if(`${piece.positionOnBoard.rankNumber}.${piece.positionOnBoard.fileNumber}` === targetPiece){\r\n                                        currentPieces[pieceIndex].positionOnBoard.rankNumber = rankNumber;\r\n                                        currentPieces[pieceIndex].positionOnBoard.fileNumber = fileNumber;\r\n                                        currentPieces[pieceIndex].noOfMoves = currentPieces[pieceIndex].noOfMoves + 1;\r\n                                    }\r\n\r\n                                    if(piece.pieceId === castleId){\r\n                                        currentPieces[pieceIndex].positionOnBoard.fileNumber = fileNumber - 1;\r\n                                    }\r\n                                }\r\n                            );\r\n\r\n                            changePieceInfo({type: 'UPDATE_PIECE_POSITION', value: currentPieces});\r\n                            // console.log(\"current pieces\", currentPieceInfo);\r\n                            setColorScheme({type: 'RETURN_TO_DEFAULT',});\r\n                            setActivityPhase({from: null, to: null, pieceId: null});\r\n\r\n                            if(turn.color === 'white'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_WHITE_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }else if(turn.color === 'black'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_BLACK_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n\r\n                            switchTurn({type: 'CHANGE_COLOR'});\r\n\r\n                        }else if(isCaseEnPassant){\r\n                            currentPieceInfo.forEach(\r\n                                (piece, pieceIndex) => {\r\n                                    if(`${piece.positionOnBoard.rankNumber}.${piece.positionOnBoard.fileNumber}` === targetPiece){\r\n                                        currentPieces[pieceIndex].positionOnBoard.rankNumber = rankNumber;\r\n                                        currentPieces[pieceIndex].positionOnBoard.fileNumber = fileNumber;\r\n                                        currentPieces[pieceIndex].noOfMoves = currentPieces[pieceIndex].noOfMoves + 1;\r\n                                    }\r\n\r\n                                    if(piece.pieceId === enPassantId){\r\n                                        currentPieces[pieceIndex].hasBeenCaptured = true;\r\n                                    }\r\n                                }\r\n                            );\r\n\r\n                            changePieceInfo({type: 'UPDATE_PIECE_POSITION', value: currentPieces});\r\n                            // console.log(\"current pieces\", currentPieceInfo);\r\n                            setColorScheme({type: 'RETURN_TO_DEFAULT',});\r\n                            setActivityPhase({from: null, to: null, pieceId: null});\r\n\r\n                            if(turn.color === 'white'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_WHITE_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }else if(turn.color === 'black'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_BLACK_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n\r\n                            switchTurn({type: 'CHANGE_COLOR'});\r\n                        }else{\r\n                            setColorScheme({type: 'RETURN_TO_DEFAULT',});\r\n                            setActivityPhase({from: null, to: null, pieceId: null});\r\n                        }  \r\n                    }else{\r\n                        let targetPiece = activityPhase.from;\r\n                        let myPiece = activityPhase.pieceId;\r\n                        let currentPieces = currentPieceInfo;\r\n                        let filteredMoves = [];\r\n                        let myPossibleMoves;\r\n                        let isSquareWithinPossible = false;\r\n\r\n                        possibleMoves.forEach(\r\n                            (piece, pieceIndex) => {\r\n                                if(piece.pieceId === myPiece){\r\n                                    myPossibleMoves = piece.moves;\r\n                                }\r\n                            }\r\n                        );\r\n                       \r\n                    \r\n                       if(myPiece !== 15 && myPiece !== 16){\r\n                        let kingInfo;\r\n                        let attackerInfo;\r\n\r\n                        //get the information of the king\r\n                        //and the information of the attacker\r\n                        currentPieceInfo.forEach(\r\n                            (piece, pieceIndex) => {\r\n                                if(piece.pieceId === isKingInCheck.attackers[0]){\r\n                                    attackerInfo = piece.positionOnBoard;\r\n                                }\r\n                                if(piece.pieceId === isKingInCheck.id){\r\n                                    kingInfo = piece.positionOnBoard;\r\n                                }\r\n                            }\r\n                        );\r\n                        filteredMoves = canMyPieceHelp(attackerInfo, kingInfo, myPossibleMoves, isKingInCheck.attackers.length);\r\n                                                \r\n                        filteredMoves.forEach(\r\n                            (move, moveIndex) => {\r\n                                if(move === `${rankNumber}.${fileNumber}`){\r\n                                    if(activityPhase.isPiecePinned){\r\n                                        //we need to check if the selected move is possible for a pinned piece\r\n                                        let isSquarePossible = canMyPieceBeHere(activityPhase.pieceId, move, currentPieceInfo, chessboardLayout, chessboardLayout.default, history);\r\n                                        if(isSquarePossible) isSquareWithinPossible = true;\r\n                                    }else{\r\n                                        isSquareWithinPossible = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        );\r\n                       }\r\n\r\n                       if(activityPhase.pieceId === 15 || activityPhase.pieceId === 16){\r\n                        myPossibleMoves.forEach(\r\n                            (move, moveIndex) => {\r\n                                if(move === `${rankNumber}.${fileNumber}`){\r\n                                    isSquareWithinPossible = true;\r\n                                }\r\n                            }\r\n                        );\r\n                       }\r\n                    \r\n                    if(isSquareWithinPossible){\r\n                        currentPieceInfo.forEach(\r\n                            (piece, pieceIndex) => {\r\n                                if(`${piece.positionOnBoard.rankNumber}.${piece.positionOnBoard.fileNumber}` === targetPiece){\r\n                                    currentPieces[pieceIndex].positionOnBoard.rankNumber = rankNumber;\r\n                                    currentPieces[pieceIndex].positionOnBoard.fileNumber = fileNumber;\r\n                                    currentPieces[pieceIndex].noOfMoves = currentPieces[pieceIndex].noOfMoves + 1;\r\n                                }\r\n                            }\r\n                        );\r\n\r\n                            changePieceInfo({type: 'UPDATE_PIECE_POSITION', value: currentPieces});\r\n                            // console.log(\"current pieces\", currentPieceInfo);\r\n                            setColorScheme({type: 'RETURN_TO_DEFAULT',});\r\n                            setActivityPhase({from: null, to: null, pieceId: null});\r\n\r\n                            if(turn.color === 'white'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_WHITE_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }else if(turn.color === 'black'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_BLACK_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n\r\n                            switchTurn({type: 'CHANGE_COLOR'});\r\n                    }else{\r\n                        chessboardSituation.forEach(\r\n                            (rankInfo, rankIndex) => {\r\n                                rankInfo.associatedFilesSituation.forEach(\r\n                                    (fileInfo, fileIndex) => {\r\n                                        if(fileInfo.pieceId === isKingInCheck.id){\r\n                                            setColorScheme({type: 'SHOW_CHECK', targetCheckSquare: `${rankInfo.rankNumber}.${fileInfo.fileNumber}`,});\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n                        );\r\n                    }\r\n                }\r\n                }\r\n\r\n    \r\n                //the user clicks on a square that has an opponent piece. He captures it\r\n                if(pieceInfo.color !== turn.color && pieceInfo.id){\r\n                    if(!isKingInCheck.status){\r\n                        let targetPiece = activityPhase.from;\r\n                        let currentPieces = currentPieceInfo;\r\n                        let isSquareWithinPossible = false;\r\n                        let allowedMove = '';\r\n\r\n                        if(activityPhase.isPiecePinned){\r\n                            //is the move selected here viable for a pinned piece?\r\n                            let isSquarePossible = canMyPieceBeHere(activityPhase.pieceId, `${rankNumber}.${fileNumber}`, currentPieceInfo, chessboardLayout, chessboardLayout.default, history);\r\n                            if(isSquarePossible) allowedMove = `${rankNumber}.${fileNumber}.X`;\r\n                                \r\n                        }\r\n\r\n                        //is the square within possible moves?\r\n                        possibleMoves.forEach(\r\n                            (piece, pieceIndex) => {\r\n                                if(piece.pieceId === activityPhase.pieceId){\r\n                                    if(activityPhase.pieceId !== 15 && activityPhase.pieceId !== 16){\r\n                                        piece.moves.forEach(\r\n                                            (move, moveIndex) => {\r\n                                                if(activityPhase.isPiecePinned){\r\n                                                    if(move === allowedMove){\r\n                                                        isSquareWithinPossible = true;\r\n                                                    }\r\n                                                }else{\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        isSquareWithinPossible = true;\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        );\r\n                                    }\r\n                                    \r\n                                    if(activityPhase.pieceId === 15 || activityPhase.pieceId === 16){   \r\n                                        piece.moves.forEach(\r\n                                            (move, moveIndex) => {\r\n                                                if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                    isSquareWithinPossible = true;\r\n                                                }   \r\n                                            }\r\n                                        );\r\n                                    }\r\n                                }\r\n                            }\r\n                        );\r\n                        \r\n                        \r\n                        if(isSquareWithinPossible){\r\n                            currentPieceInfo.forEach(\r\n                                (piece, pieceIndex) => {\r\n                                    if(`${piece.positionOnBoard.rankNumber}.${piece.positionOnBoard.fileNumber}` === `${rankNumber}.${fileNumber}`){\r\n                                        currentPieces[pieceIndex].hasBeenCaptured = true;\r\n                                    }\r\n                                    if(`${piece.positionOnBoard.rankNumber}.${piece.positionOnBoard.fileNumber}` === targetPiece){\r\n                                        currentPieces[pieceIndex].positionOnBoard.rankNumber = rankNumber;\r\n                                        currentPieces[pieceIndex].positionOnBoard.fileNumber = fileNumber;\r\n                                        currentPieces[pieceIndex].noOfMoves = currentPieces[pieceIndex].noOfMoves + 1;\r\n                                    }\r\n                                }\r\n                            );\r\n\r\n                            changePieceInfo({type: 'UPDATE_PIECE_POSITION', value: currentPieces});\r\n                            // console.log(\"current pieces\", currentPieceInfo);\r\n                            setColorScheme({type: 'RETURN_TO_DEFAULT',});\r\n                            setActivityPhase({from: null, to: null, pieceId: null});\r\n\r\n                            if(turn.color === 'white'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_WHITE_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }else if(turn.color === 'black'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_BLACK_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n\r\n                            switchTurn({type: 'CHANGE_COLOR'});\r\n                        }else{\r\n                            setColorScheme({type: 'RETURN_TO_DEFAULT',});\r\n                            setActivityPhase({from: null, to: null, pieceId: null});\r\n                        }\r\n                    }else{\r\n                        //the piece can only capture according to it's filtered possible moves\r\n                        let targetPiece = activityPhase.from;\r\n                        let currentPieces = currentPieceInfo;\r\n                        let isSquareWithinPossible = false;\r\n                        let filteredMoves = []\r\n                        let myPossibleMoves;\r\n                        let myPiece = activityPhase.pieceId;\r\n\r\n                        possibleMoves.forEach(\r\n                            (piece, pieceIndex) => {\r\n                                if(piece.pieceId === myPiece){\r\n                                    myPossibleMoves = piece.moves;\r\n                                }\r\n                            }\r\n                        );\r\n                       \r\n                    \r\n                       if(myPiece !== 15 && myPiece !== 16){\r\n                        let kingInfo;\r\n                        let attackerInfo;\r\n\r\n                        //get the information of the king\r\n                        //and the information of the attacker\r\n                        currentPieceInfo.forEach(\r\n                            (piece, pieceIndex) => {\r\n                                if(piece.pieceId === isKingInCheck.attackers[0]){\r\n                                    attackerInfo = piece.positionOnBoard;\r\n                                }\r\n                                if(piece.pieceId === isKingInCheck.id){\r\n                                    kingInfo = piece.positionOnBoard;\r\n                                }\r\n                            }\r\n                        );\r\n                        filteredMoves = canMyPieceHelp(attackerInfo, kingInfo, myPossibleMoves, isKingInCheck.attackers.length);\r\n                                                                        \r\n                        filteredMoves.forEach(\r\n                            (move, moveIndex) => {\r\n                                if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                    if(activityPhase.isPiecePinned){\r\n                                        //is the move selected here viable for a pinned piece?\r\n                                        let isSquarePossible = canMyPieceBeHere(activityPhase.pieceId, `${rankNumber}.${fileNumber}`, currentPieceInfo, chessboardLayout, chessboardLayout.default, history);\r\n                                        if(isSquarePossible) isSquareWithinPossible = true\r\n                                            \r\n                                    }else{\r\n                                        isSquareWithinPossible = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        );\r\n                       }\r\n                       \r\n                       if(activityPhase.pieceId === 15 || activityPhase.pieceId === 16){\r\n                        myPossibleMoves.forEach(\r\n                            (move, moveIndex) => {\r\n                                if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                    isSquareWithinPossible = true;\r\n                                }\r\n                            }\r\n                        );\r\n                       }\r\n\r\n                        if(isSquareWithinPossible){\r\n                            currentPieceInfo.forEach(\r\n                                (piece, pieceIndex) => {\r\n                                    if(piece.pieceId === pieceInfo.id){\r\n                                        currentPieces[pieceIndex].hasBeenCaptured = true;\r\n                                    }\r\n                                    if(`${piece.positionOnBoard.rankNumber}.${piece.positionOnBoard.fileNumber}` === targetPiece){\r\n                                        currentPieces[pieceIndex].positionOnBoard.rankNumber = rankNumber;\r\n                                        currentPieces[pieceIndex].positionOnBoard.fileNumber = fileNumber;\r\n                                        currentPieces[pieceIndex].noOfMoves = currentPieces[pieceIndex].noOfMoves + 1;\r\n                                    }\r\n                                }\r\n                            );\r\n\r\n                            changePieceInfo({type: 'UPDATE_PIECE_POSITION', value: currentPieces});\r\n                            // console.log(\"current pieces\", currentPieceInfo);\r\n                            setColorScheme({type: 'RETURN_TO_DEFAULT',});\r\n                            setActivityPhase({from: null, to: null, pieceId: null});\r\n\r\n                            if(turn.color === 'white'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_WHITE_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }else if(turn.color === 'black'){\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === activityPhase.pieceId){\r\n                                            piece.moves.forEach(\r\n                                                (move, moveIndex) => {\r\n                                                    if(move.substring(0,3) === `${rankNumber}.${fileNumber}`){\r\n                                                        updateHistory({type: 'ADD_BLACK_MOVE', value: {id:activityPhase.pieceId, move}});\r\n                                                    }\r\n                                                }\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n\r\n                            switchTurn({type: 'CHANGE_COLOR'});\r\n                        }else{\r\n                            setActivityPhase({from: null, to: null, pieceId: null});\r\n                            let targetCheckSquare;\r\n                            let kingInCheck = isKingInCheck.id;\r\n                            kingPossibleMoves.forEach(\r\n                                (king, kingIndex) => {\r\n                                    if(king.pieceId === kingInCheck){\r\n                                        targetCheckSquare = `${king.positionOnBoard.rankNumber}.${king.positionOnBoard.fileNumber}`;\r\n                                    }\r\n                                }\r\n                            )\r\n                            chessboardSituation.forEach(\r\n                                (rankInfo, rankIndex) => {\r\n                                    rankInfo.associatedFilesSituation.forEach(\r\n                                        (fileInfo, fileIndex) => {\r\n                                            if(fileInfo.pieceId === isKingInCheck.id){\r\n                                                setColorScheme({type: 'SHOW_CHECK', targetCheckSquare,});\r\n                                            }\r\n                                        }\r\n                                    );\r\n                                }\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                //the user clicks on a piece that is his\r\n                if(pieceInfo.color === turn.color && pieceInfo.id){\r\n                    \r\n                    if(!isKingInCheck.status){\r\n                        if(pieceInfo.id === activityPhase.pieceId){\r\n                            setColorScheme({type: 'RETURN_TO_DEFAULT',});\r\n                            setActivityPhase({from: null, to: null, pieceId: null});\r\n                        }else{\r\n                            let possibleSquares = [];\r\n                        \r\n                            possibleMoves.forEach(\r\n                                (piece, pieceIndex) => {\r\n                                    if(piece.pieceId === pieceInfo.id){\r\n                                        possibleSquares = piece.moves;\r\n                                    }\r\n                                }\r\n                            );\r\n\r\n                            //check if the piece is pinned\r\n                            let myPieceIsPinned = isMyPiecePinned(rankNumber, fileNumber, chessboardSituation, chessboardLayout.default, history, currentPieceInfo, turn.color);\r\n                            if(myPieceIsPinned){\r\n                                //we need to investigate every move by a pinned piece to ensure the move will not leave the king in check\r\n                                let newPossibleSquares = [];\r\n                                possibleSquares.forEach(\r\n                                    (move, moveIndex) => {\r\n                                        let isSquarePossible = canMyPieceBeHere(pieceInfo.id, move, currentPieceInfo, chessboardLayout, chessboardLayout.default, history);\r\n                                        if(isSquarePossible){\r\n                                            newPossibleSquares = [\r\n                                                ...newPossibleSquares,\r\n                                                move\r\n                                            ]\r\n                                        }\r\n                                    }\r\n                                );\r\n\r\n                                possibleSquares = newPossibleSquares;\r\n                                \r\n                                setColorScheme({type: 'POSSIBLE_MOVES', targetSquare: `${rankNumber}.${fileNumber}`, possibleSquares,targetCheckSquare: null,});\r\n                                setActivityPhase({...activityPhase, from:  `${rankNumber}.${fileNumber}`, pieceId: pieceInfo.id, isPiecePinned: true,});\r\n                            }else{\r\n                                setColorScheme({type: 'POSSIBLE_MOVES', targetSquare: `${rankNumber}.${fileNumber}`, possibleSquares,targetCheckSquare: null,});\r\n                                setActivityPhase({...activityPhase, from:  `${rankNumber}.${fileNumber}`, pieceId: pieceInfo.id});\r\n                            }\r\n                            \r\n                        }\r\n                    }else{\r\n                        if(pieceInfo.id === activityPhase.pieceId){\r\n                            chessboardSituation.forEach(\r\n                                (rankInfo, rankIndex) => {\r\n                                    rankInfo.associatedFilesSituation.forEach(\r\n                                        (fileInfo, fileIndex) => {\r\n                                            if(fileInfo.pieceId === isKingInCheck.id){\r\n                                                setColorScheme({type: 'SHOW_CHECK', targetCheckSquare: `${rankInfo.rankNumber}.${fileInfo.fileNumber}`,});\r\n                                            }\r\n                                        }\r\n                                    );\r\n                                }\r\n                            );\r\n                            setActivityPhase({from: null, to: null, pieceId: null});\r\n                        }else{\r\n                            //check whether the player is moving a piece of the turn's color\r\n                            if(turn.color === pieceInfo.color){\r\n                                let possibleSquares = []\r\n                                //filter this piece's possible moves\r\n                                //allow only those that can help the king get out of check\r\n                                let myPossibleMoves;\r\n                                possibleMoves.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === pieceInfo.id){\r\n                                            myPossibleMoves = piece.moves;\r\n                                        }\r\n                                    }\r\n                                );\r\n\r\n                                let kingInfo;\r\n                                let attackerInfo;\r\n                                let myPieceIsPinned = isMyPiecePinned(rankNumber, fileNumber, chessboardSituation, chessboardLayout.default, history, currentPieceInfo, turn.color);\r\n\r\n                                //get the information of the king\r\n                                //and the information of the attacker\r\n                                currentPieceInfo.forEach(\r\n                                    (piece, pieceIndex) => {\r\n                                        if(piece.pieceId === isKingInCheck.attackers[0]){\r\n                                            attackerInfo = piece.positionOnBoard;\r\n                                        }\r\n                                        if(piece.pieceId === isKingInCheck.id){\r\n                                            kingInfo = piece.positionOnBoard;\r\n                                        }\r\n                                    }\r\n                                );\r\n                            \r\n                            if(pieceInfo.piece !== 'King'){\r\n                                possibleSquares = canMyPieceHelp(attackerInfo, kingInfo, myPossibleMoves, isKingInCheck.attackers.length);\r\n\r\n                                //check if the piece is pinned\r\n                                \r\n                                if(myPieceIsPinned){\r\n                                    //we need to investigate every move by a pinned piece to ensure the move will not leave the king in check\r\n                                    let newPossibleSquares = [];\r\n                                    possibleSquares.forEach(\r\n                                        (move, moveIndex) => {\r\n                                            let isSquarePossible = canMyPieceBeHere(pieceInfo.id, move, currentPieceInfo, chessboardLayout, chessboardLayout.default, history);\r\n                                            if(isSquarePossible){\r\n                                                newPossibleSquares = [\r\n                                                    ...newPossibleSquares,\r\n                                                    move\r\n                                                ]\r\n                                            }\r\n                                        }\r\n                                    );\r\n\r\n                                    possibleSquares = newPossibleSquares;\r\n                                }\r\n                            }else{\r\n                                myPossibleMoves.forEach(\r\n                                    (move, moveIndex) => {\r\n                                        if(move.search(\"Cl\") === -1 && move.search(\"Cs\") === -1){\r\n                                            possibleSquares = [\r\n                                                ...possibleSquares,\r\n                                                move\r\n                                            ];\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n\r\n                                let targetCheckSquare;\r\n                                chessboardSituation.forEach(\r\n                                    (rankInfo, rankIndex) => {\r\n                                        rankInfo.associatedFilesSituation.forEach(\r\n                                            (fileInfo, fileIndex) => {\r\n                                                if(fileInfo.pieceId === isKingInCheck.id){\r\n                                                    targetCheckSquare = `${rankInfo.rankNumber}.${fileInfo.fileNumber}`;\r\n                                                }\r\n                                            }\r\n                                        );\r\n                                    }\r\n                                );\r\n            \r\n                                if(myPieceIsPinned){\r\n                                    setColorScheme({type: 'POSSIBLE_MOVES', targetSquare: `${rankNumber}.${fileNumber}`, possibleSquares, targetCheckSquare,});\r\n                                    setActivityPhase({...activityPhase, from:  `${rankNumber}.${fileNumber}`, pieceId: pieceInfo.id, isPiecePinned: true,});\r\n                                }else{\r\n                                    setColorScheme({type: 'POSSIBLE_MOVES', targetSquare: `${rankNumber}.${fileNumber}`, possibleSquares, targetCheckSquare,});\r\n                                    setActivityPhase({...activityPhase, from:  `${rankNumber}.${fileNumber}`, pieceId: pieceInfo.id});\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n    \r\n            }\r\n            \r\n        }\r\n        //launchPlayerActivity is here\r\n    }\r\n    \r\n    const displayBoard = chessboardInfo.map(\r\n        (rankInfo, rankIndex) => {\r\n\r\n            return(\r\n                rankInfo.associatedFiles.map(\r\n                    (fileInfo, fileIndex) => {\r\n\r\n                        //prepare a check for whether this square holds a piece\r\n                        let piece = '';\r\n                        let color;\r\n                        let id;\r\n\r\n                        //loop through the pieces and find if there is any piece for this square\r\n                        currentPieceInfo.forEach(\r\n                            singlePiece => {\r\n                                if(!singlePiece.hasBeenCaptured \r\n                                    && singlePiece.positionOnBoard.rankNumber === rankInfo.rankNumber \r\n                                    && singlePiece.positionOnBoard.fileNumber === fileInfo.fileNumber){\r\n                                    //check the piece that exists and return the appropriate svg\r\n                                    if(singlePiece.pieceName === 'Pawn'){\r\n                                    piece = 'Pawn';\r\n                                    color = singlePiece.pieceColor;\r\n                                    id = singlePiece.pieceId;\r\n                                    }\r\n\r\n                                    if(singlePiece.pieceName === 'King'){\r\n                                    piece = 'King';\r\n                                    color = singlePiece.pieceColor;\r\n                                    id = singlePiece.pieceId;\r\n                                    }\r\n\r\n                                    if(singlePiece.pieceName === 'Queen'){\r\n                                    piece = 'Queen';\r\n                                    color = singlePiece.pieceColor;\r\n                                    id = singlePiece.pieceId;\r\n                                    }\r\n\r\n                                    if(singlePiece.pieceName === 'Rook'){\r\n                                    piece = 'Rook';\r\n                                    color = singlePiece.pieceColor;\r\n                                    id = singlePiece.pieceId;\r\n                                    }\r\n\r\n                                    if(singlePiece.pieceName === 'Knight'){\r\n                                    piece = 'Knight';\r\n                                    color = singlePiece.pieceColor;\r\n                                    id = singlePiece.pieceId;\r\n                                    }\r\n\r\n                                    if(singlePiece.pieceName === 'Bishop'){\r\n                                        piece = 'Bishop';\r\n                                        color = singlePiece.pieceColor;\r\n                                        id = singlePiece.pieceId;\r\n                                    }\r\n                                }\r\n                            }\r\n                        );\r\n\r\n                        if(piece === 'Pawn'){\r\n                            return(\r\n                                <div\r\n                                onClick={() => launchPlayerActivity(chessboardInfo[rankIndex].rankNumber, chessboardInfo[rankIndex].associatedFiles[fileIndex].fileNumber, {id, piece, color})}\r\n                                className={chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass}\r\n                                key={`${rankIndex} ${fileIndex}`}\r\n                                style={{width: '70px', height: '70px', backgroundColor: chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass === 'normal' ? chessboardInfo[rankIndex].associatedFiles[fileIndex].color : null,}}\r\n                                ><Pawn pieceColor={color} />\r\n                                </div>\r\n                            );\r\n                        }\r\n\r\n                        if(piece === 'King'){\r\n                            return(\r\n                                <div\r\n                                onClick={() => launchPlayerActivity(chessboardInfo[rankIndex].rankNumber, chessboardInfo[rankIndex].associatedFiles[fileIndex].fileNumber, {id, piece, color})}\r\n                                className={chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass}\r\n                                key={`${rankIndex} ${fileIndex}`}\r\n                                style={{width: '70px', height: '70px', backgroundColor: chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass === 'normal' ? chessboardInfo[rankIndex].associatedFiles[fileIndex].color : null,}}\r\n                                ><King pieceColor={color} />\r\n                                </div>\r\n                            );\r\n                        }\r\n\r\n                        if(piece === 'Queen'){\r\n                            return(\r\n                                <div\r\n                                onClick={() => launchPlayerActivity(chessboardInfo[rankIndex].rankNumber, chessboardInfo[rankIndex].associatedFiles[fileIndex].fileNumber, {id, piece, color})}\r\n                                className={chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass}\r\n                                key={`${rankIndex} ${fileIndex}`}\r\n                                style={{width: '70px', height: '70px', backgroundColor: chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass === 'normal' ? chessboardInfo[rankIndex].associatedFiles[fileIndex].color : null,}}\r\n                                ><Queen pieceColor={color} />\r\n                                </div>\r\n                            );\r\n                        }\r\n\r\n                        if(piece === 'Knight'){\r\n                            return(\r\n                                <div\r\n                                onClick={() => launchPlayerActivity(chessboardInfo[rankIndex].rankNumber, chessboardInfo[rankIndex].associatedFiles[fileIndex].fileNumber, {id, piece, color})}\r\n                                className={chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass}\r\n                                key={`${rankIndex} ${fileIndex}`}\r\n                                style={{width: '70px', height: '70px', backgroundColor: chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass === 'normal' ? chessboardInfo[rankIndex].associatedFiles[fileIndex].color : null,}}\r\n                                ><Knight pieceColor={color} />\r\n                                </div>\r\n                            );\r\n                        }\r\n\r\n                        if(piece === 'Bishop'){\r\n                            return(\r\n                                <div\r\n                                onClick={() => launchPlayerActivity(chessboardInfo[rankIndex].rankNumber, chessboardInfo[rankIndex].associatedFiles[fileIndex].fileNumber, {id, piece, color})}\r\n                                className={chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass}\r\n                                key={`${rankIndex} ${fileIndex}`}\r\n                                style={{width: '70px', height: '70px', backgroundColor: chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass === 'normal' ? chessboardInfo[rankIndex].associatedFiles[fileIndex].color : null,}}\r\n                                ><Bishop pieceColor={color} />\r\n                                </div>\r\n                            );\r\n                        }\r\n\r\n                        if(piece === 'Rook'){\r\n                            return(\r\n                                <div\r\n                                onClick={() => launchPlayerActivity(chessboardInfo[rankIndex].rankNumber, chessboardInfo[rankIndex].associatedFiles[fileIndex].fileNumber, {id, piece, color})}\r\n                                className={chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass}\r\n                                key={`${rankIndex} ${fileIndex}`}\r\n                                style={{width: '70px', height: '70px', backgroundColor: chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass === 'normal' ? chessboardInfo[rankIndex].associatedFiles[fileIndex].color : null,}}\r\n                                ><Rook pieceColor={color} />\r\n                                </div>\r\n                            );\r\n                        }\r\n\r\n                        return(\r\n                            <div\r\n                            onClick={() => launchPlayerActivity(chessboardInfo[rankIndex].rankNumber, chessboardInfo[rankIndex].associatedFiles[fileIndex].fileNumber, {id: null})}\r\n                            className={chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass}\r\n                            key={`${rankIndex} ${fileIndex}`}\r\n                            style={{width: '70px', height: '70px', backgroundColor: chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass === 'normal' ||  chessboardInfo[rankIndex].associatedFiles[fileIndex].squareClass === 'amongPossibleSquares' ? chessboardInfo[rankIndex].associatedFiles[fileIndex].color : null,}}\r\n                            >\r\n                            <div></div>\r\n                            </div>\r\n                        );\r\n\r\n                    }\r\n                )\r\n            )\r\n        }\r\n        );\r\n\r\n    // console.log(\"history\", history);\r\n\r\n    return(\r\n        <>\r\n        <div style={{\r\n         width: '562px',\r\n         height: '562px',\r\n         display: 'flex', \r\n         flexFlow: 'row wrap',\r\n         alignItems: 'flex-start',\r\n         alignContent: 'flex-start',\r\n         border: '1px solid #000000'\r\n           }}>\r\n            {\r\n                displayBoard.map(rank => rank.map((file, index) => <React.Fragment key={index}>{file}</React.Fragment>))\r\n            }\r\n        </div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(Chessboard);","import React from 'react';\r\nimport King from './pieces/King';\r\n\r\nconst Screen = ({turn, screenContent}) => {\r\n    return(\r\n        <>\r\n            <div style={{\r\n                width: '562px',\r\n                height: '100px',\r\n                backgroundColor: '#f0fcfc',\r\n                borderTop: '1px solid #000000',\r\n                borderLeft: '1px solid #000000',\r\n                borderRight: '1px solid #000000',\r\n                display: 'flex',\r\n                flexFlow: 'row wrap',\r\n                // borderRadius:'10px 10px 0px 0px'\r\n            }}>\r\n                {\r\n                    turn.color === 'white' ?\r\n                    <King pieceColor={turn.color}/>:\r\n                    <King pieceColor={turn.color}/>\r\n                }\r\n                 <div>\r\n                    <div style={{\r\n                        color: '#ff0000',\r\n                        fontSize: '2em',\r\n                        fontWeight: 'bolder',\r\n                    }}>\r\n                        {screenContent.message}\r\n                    </div>\r\n                    <div style={{\r\n                         color: '#ff0000',\r\n                         fontSize: '2em',\r\n                         fontWeight: 'bolder',\r\n                    }}>\r\n                        {screenContent.verdict}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n           \r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(Screen);","import React from 'react';\r\n\r\nimport Queen from './pieces/Queen';\r\nimport Rook from './pieces/Rook';\r\nimport Bishop from './pieces/Bishop';\r\nimport Knight from './pieces/Knight';\r\nimport '../styles/boardStyles.css';\r\n\r\n\r\nconst PromoteOptions = ({displayStatus, pieceColor, selectPromotionPiece}) => {\r\n    // console.log(\"display status\", displayStatus);\r\n    // console.log(\"piece color\", pieceColor);\r\n    return(\r\n        <div \r\n        className=\"promotionContainer\"\r\n        style={{\r\n            display: displayStatus,\r\n        }}\r\n        >\r\n            <div \r\n            className=\"promotionSquare\"\r\n            onClick={() => selectPromotionPiece('Queen')}\r\n            ><Queen pieceColor={pieceColor}/></div>\r\n            <div \r\n            className=\"promotionSquare\"\r\n            onClick={() => selectPromotionPiece('Rook')}\r\n            ><Rook pieceColor={pieceColor}/></div>\r\n            <div \r\n            className=\"promotionSquare\"\r\n            onClick={() => selectPromotionPiece('Bishop')}\r\n            ><Bishop pieceColor={pieceColor}/></div>\r\n            <div \r\n            className=\"promotionSquare\"\r\n            onClick={() => selectPromotionPiece('Knight')}\r\n            ><Knight pieceColor={pieceColor}/></div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default React.memo(PromoteOptions);","import React,{\r\n    useReducer,\r\n    useState,\r\n    useEffect,\r\n} from 'react';\r\nimport Chessboard from './Chessboard';\r\nimport Screen from './Screen';\r\nimport PromoteOptions from './PromoteOptions';\r\nimport '../styles/appStyles.css';\r\n\r\n//this is the outer app component. It manages the board page\r\n\r\n//redducer function that changes player to play\r\nconst changeTurn = (currentTurn, action) => {\r\n    switch(action.type){\r\n        case 'CHANGE_COLOR':\r\n            let color;\r\n            if(currentTurn.color === 'white') color = 'black';\r\n            else color = 'white';\r\n\r\n            return({color,});\r\n        default:\r\n            return currentTurn;\r\n    }\r\n}\r\n\r\n//variable that holds the initial board layout\r\n//the board layout will default to black player up and white player down\r\nconst initialChessboardLayout = {\r\n    ranksPlacement: [8, 7, 6, 5, 4, 3, 2, 1],\r\n    filesPlacement: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],\r\n    fileNumbers: [1, 2, 3, 4, 5, 6, 7, 8],\r\n    default: true,\r\n};\r\n\r\n//the reducer function that mutates the board layout\r\nconst exchangeChessBoardLayout = (currentLayout, action) => {\r\n    switch(action.type){\r\n        case 'EXCHANGE':\r\n            let newDefault\r\n            if(currentLayout.default){\r\n                newDefault = false;\r\n            }else{\r\n                newDefault = true;\r\n            }\r\n            return ({\r\n                ranksPlacement: currentLayout.ranksPlacement.reverse(),\r\n                filesPlacement: currentLayout.filesPlacement.reverse(),\r\n                fileNumbers: currentLayout.fileNumbers.reverse(),\r\n                default: newDefault,\r\n            });\r\n        default: \r\n            return currentLayout;\r\n    }\r\n}\r\nconst App = () => \r\n{\r\n    //state variable that holds screen text content ** could be temporary **\r\n    const [screenContent, setScreenContent] = useState({\r\n        message: '',\r\n        verdict: ''\r\n    });\r\n\r\n    //state variable that keeps track of the board layout\r\n    const [chessboardLayout, switchChessBoardLayout] = useReducer(exchangeChessBoardLayout, initialChessboardLayout);\r\n\r\n    //state variable that keeps track of player to play\r\n    const [turn, dispatchTurn] = useReducer(changeTurn,{\r\n        color: 'white',\r\n    });\r\n\r\n    //state variable that keeps track of the promotion display status and piece color\r\n    const [promotion, setPromotion] = useState({\r\n        displayStatus: 'none',\r\n        pieceColor: 'white'\r\n    });\r\n\r\n    //a callback function that can alter the promotion state\r\n    const changePromotionState = (displayStatus, pieceColor) => {\r\n        setPromotion({\r\n            displayStatus,\r\n            pieceColor,\r\n        });\r\n    }\r\n\r\n    //a state variable that keeps track of the promotion piece that has been selected\r\n    const [promotionPiece, setPromotionPiece] = useState(null);\r\n\r\n    //a callback function that can change this promotion piece state\r\n    const selectPromotionPiece = pieceName => {\r\n        setPromotion({\r\n            ...promotion,\r\n            displayStatus: 'none',\r\n        });\r\n        setPromotionPiece(pieceName);\r\n    }\r\n    \r\n    //state variable that keeps track of the movecount\r\n    const [moveCount, setMoveCount] = useState(0);\r\n\r\n    //update the movecount whenever turn is white\r\n    useEffect(\r\n        () => {\r\n            if(turn.color === 'white'){\r\n                setMoveCount(\r\n                    previousCount => {\r\n                        return previousCount + 1;\r\n                    }\r\n                );\r\n            }\r\n        }, [turn]\r\n    );\r\n\r\n    return(\r\n     <>\r\n        <PromoteOptions\r\n            displayStatus={promotion.displayStatus}\r\n            pieceColor={promotion.pieceColor}\r\n            selectPromotionPiece={selectPromotionPiece}\r\n        />\r\n        <Screen\r\n                turn={turn}\r\n                screenContent={screenContent}\r\n        />\r\n                    \r\n        <Chessboard \r\n            chessboardLayout={chessboardLayout}\r\n            turn={turn}\r\n            switchTurn={dispatchTurn}\r\n            moveCount={moveCount}\r\n            changePromotionState={changePromotionState}\r\n            promotionPiece={promotionPiece}\r\n            setPromotionPiece={setPromotionPiece}\r\n            setScreenContent={setScreenContent}\r\n        />\r\n\r\n        <button\r\n        onClick={() => switchChessBoardLayout({type: 'EXCHANGE'})}\r\n        className=\"options\"\r\n        >Flip Board</button>\r\n     </>\r\n    );\r\n}\r\n\r\nexport default App;","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './components/App';\r\n\r\nconst rootNode = document.querySelector(\"#root\");\r\nReactDOM.render(\r\n    <App/>, rootNode\r\n);"],"sourceRoot":""}